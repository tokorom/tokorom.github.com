<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on TOKOROM BLOG</title>
    <link>https://www.tokoro.me/posts/</link>
    <description>Recent content in Posts on TOKOROM BLOG</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <copyright>Copyright © tokorom. All Rights Reserved.</copyright>
    <lastBuildDate>Thu, 08 May 2025 11:00:00 +0900</lastBuildDate><atom:link href="https://www.tokoro.me/posts/atom.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CursorでAIの支援を得ながらブログ記事を書く</title>
      <link>https://www.tokoro.me/posts/writing-blog-with-cursor-ai/</link>
      <pubDate>Thu, 08 May 2025 11:00:00 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/writing-blog-with-cursor-ai/</guid>
      <description>はじめに まだAIによる執筆支援はうまく活用できていません（アドバイス求む！） Cursor/VSCode自体の設定については別途こちらに書きました 記事のファイル作成と見出し案 まず記事を書くにあたってタイトルだけ決めて、CursorのAgentに以下のように依頼しました：
[title] というタイトルでブログ記事のファイルを作ってください。 記事のファイル名は index.md で、content/posts ディレクトリに記事のタイトルを簡易な英語にした新しいディレクトリを作り、その直下に設置してください。 Front Matterのtitleには指定したタイトルを、tagsには記事内容に適したTagを幾つか設定してください。 記事の本文を書く必要はありませんので、この記事を書くための見出しの案だけ作ってください。見出しはMarkdown形式で連番を付与せずにSEOも考慮して構成してください。 これにより、適切なディレクトリを作成し、index.mdを設置し、そこに見出しの案を書いてもらうことができます。
はじめは文章の案も作ってもらったのですが、イメージ通りの文面になかなかならないため、見出しだけを作ってもらうことにしました。
たとえば、このブログ記事のタイトルに対してCursorが作ってくれた見出しの案が以下です：
## CursorのAI機能とは ## ブログ記事執筆での活用方法 ### 文章の推敲と改善 ### コードブロックの生成と最適化 ### 画像の最適化と管理 ### SEO対策の提案 ## 実践的な使い方のコツ ### プロンプトの工夫 ### 段階的な改善 ### コードと文章のバランス ## 注意点と制限事項 ## まとめ ## 今後の展望 けっきょくこのまま使うわけではないですが、ゼロから書き始めるよりは良いかなということで。。。 このあたりはAIへの指示をもっときちんとすれば精度が良くなるのかも？
アイキャッチ画像の生成と保存 結果としてこれはCursor単体ではできていません。
Cursorに「この記事のアイキャッチ画像を生成してtop.pngという名前で保存してください。」とお願いしても、
申し訳ありませんが、現在のツールセットには画像を生成する機能が含まれていません。
とつれない反応。
MCPなどを使いこなせば実現できそうですが、いったんあきらめて、外部でChatGPTに作ってもらった画像をドラッグ＆ドロップすることにしました。
ChatGPTへのお願いのしかた いきなりアイキャッチ画像の生成をお願いすると、長い時間をかけてイメージと違うものが生成されて無駄になることが多かったため、まずは以下のように依頼します：
[title] というタイトルのブログ記事のアイキャッチ画像を作りたいのですが、まずは画像を生成せずにテキストベースで、どのようなキーワードで作成すべきかの案をいくつか出してください。 そのままコピペできるようにカンマ区切りのおすすめのキーワードの組み合わせを日本語で箇条書きで列挙してください。 案の中のいくつかには、犬というキーワードも含めてください。 これで、そのままコピペで使いやすいよう、カンマ区切りのキーワードの組み合わせを箇条書きで列挙してもらいます。
その中でイメージにあったキーワードの組み合わせがあればそれをコピーして以下のように画像生成をお願いします：
[keywords] というキーワードで1200x630のアイキャッチ画像を作ってください。 画像にテキストは含めないでください。 これで少なくともイメージと全く違うものにはならないはずなので、そのあと、何度かリテイクすればそれっぽいアイキャッチ画像ができるはずです。
本文を書く これもやってみたものの、まだうまく活用できていません。
Cursorに作ってもらった見出しを自分で整理したら、見出しごとに本文を書いていきます。
この際、Cursorの ⌘K による Inline Generation で本文の案を作ってもらうこともできます。 ある程度書き始めてから このセクションの続きを書いて。次のセクションには行かないで。 とすると、書き途中のセクションに限定して案を出してくれます。</description>
    </item>
    
    <item>
      <title>Cursor/VSCodeでブログ記事を書くときの基本設定</title>
      <link>https://www.tokoro.me/posts/basic-settings-for-blog-writing/</link>
      <pubDate>Tue, 06 May 2025 15:00:00 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/basic-settings-for-blog-writing/</guid>
      <description>最近は本業のプログラミングを専らAIエディタのCursorで書くようになりました。
このブログ記事はずっとVimで書き続けていたのですが、こちらもVSCodeやAIの恩恵を受けられるのではないかと考え、環境の移行を開始しました。
本記事では、その移行でCursor（VSCode）にどのような設定を加えたかをまとめています。 まだこの設定で運用を開始したばかりの段階ですので、改善点やアドバイスをいただけると幸いです！
前提条件 わたしはCursor/VSCode初級者です ブログは昔からの経緯でStatic Site GeneratorのHugoを使っています これから新しく採択するなら別のものにすると思いますが、今Generatorに不満があるわけではないのでそのままで わたしはVimmerなのでVSCodeVimを使いますがこの記事ではそのことに触れません 別途記事を書く予定です この記事ではAIの利用方法については触れません AIの利用については別途こちらに書きました Cursor導入後にやったこと（要約） この記事では以下の内容について紹介します。
Front Matterを設置しやすくする そのほかスニペットを設定 画像をドラッグ＆ドロップして記事に挿入する タスクで画像のファイルサイズ縮小をまとめてやる 記事のリアルタイムプレビュー 拡張機能 Front Matterを設置しやすくする このブログ記事では具体的には、
--- title: &amp;quot;Cursor/VSCodeでブログ記事を書くときの基本設定&amp;quot; date: 2025-05-06T15:00:00+09:00 draft: false authors: [tokorom] tags: [&amp;quot;vscode&amp;quot;, &amp;quot;cursor&amp;quot;, &amp;quot;blog&amp;quot;, &amp;quot;AI&amp;quot;, &amp;quot;markdown&amp;quot;] images: [/posts/basic-settings-for-blog-writing/top.png] --- というFront Matterを設定しています。
Cursorに自動で設定してもらってもそれっぽくはなるのですが安定しなかったので以下のスニペットを .vscode/markdown.code-snippets に設定しました。
{ &amp;quot;Hugo Blog Markdown Front Matter&amp;quot;: { &amp;quot;scope&amp;quot;: &amp;quot;markdown&amp;quot;, &amp;quot;prefix&amp;quot;: &amp;quot;markdown-frontmatter&amp;quot;, &amp;quot;body&amp;quot;: [ &amp;quot;---&amp;quot;, &amp;quot;title: ${1:${TM_DIRECTORY/.*\\/([^\\/]+)\\/?$/$1/}}&amp;quot;, &amp;quot;date: ${CURRENT_YEAR}-${CURRENT_MONTH}-${CURRENT_DATE}T${CURRENT_HOUR}:${CURRENT_MINUTE}:${CURRENT_SECOND}+09:00&amp;quot;, &amp;quot;draft: false&amp;quot;, &amp;quot;authors: [tokorom]&amp;quot;, &amp;quot;tags: [$2]&amp;quot;, &amp;quot;images: [/posts/${TM_DIRECTORY/.</description>
    </item>
    
    <item>
      <title>[WWDC24] SwiftUIの新機能のまとめ</title>
      <link>https://www.tokoro.me/posts/wwdc24-whats-new-in-swiftui/</link>
      <pubDate>Tue, 25 Jun 2024 10:56:06 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/wwdc24-whats-new-in-swiftui/</guid>
      <description>WWDC24の What’s new in SwiftUI のまとめです。
今回、このセッションで紹介される項目の数が例年以上に多すぎてびっくりでした。 セッションでは短い間隔でポンポンとたくさんの機能が流れるように紹介されていきます。
このまとめでは、セッションでは軽く触れられた程度の内容も、APIリファレンスへのリンクをつけるなどしてもう少しだけ補足します。
このセッションを視聴する/この記事を参照する目的は、WWDC24で発表されたSwiftUIの新機能をさらっと把握し頭の中にインデックスを貼ることだと思います。
サイドバー/タブバー サイドバー/タブバーがより柔軟に フローティングタブバーをサポート 項目の並び替えや使用頻度の低いオプションの非表示など、ユーザーが自分好みにカスタマイズすることもできる TabViewに内包する要素も新しいタイプセーフな書き方に struct KaraokeTabView: View { @State var customization = TabViewCustomization() var body: some View { TabView { Tab(&amp;quot;Parties&amp;quot;, image: &amp;quot;party.popper&amp;quot;) { PartiesView(parties: Party.all) } .customizationID(&amp;quot;karaoke.tab.parties&amp;quot;) Tab(&amp;quot;Planning&amp;quot;, image: &amp;quot;pencil.and.list.clipboard&amp;quot;) { PlanningView() } .customizationID(&amp;quot;karaoke.tab.planning&amp;quot;) Tab(&amp;quot;Attendance&amp;quot;, image: &amp;quot;person.3&amp;quot;) { AttendanceView() } .customizationID(&amp;quot;karaoke.tab.attendance&amp;quot;) Tab(&amp;quot;Song List&amp;quot;, image: &amp;quot;music.note.list&amp;quot;) { SongListView() } .customizationID(&amp;quot;karaoke.tab.songlist&amp;quot;) } .tabViewStyle(.sidebarAdaptable) .tabViewCustomization($customization) } } tabViewStyleに sidebarAdaptable を指定することで、プラットフォームごとに柔軟にサイドバー OR タブバーが適用される</description>
    </item>
    
    <item>
      <title>[visionOS] 最もシンプルな完全没入空間を試すサンプルコード</title>
      <link>https://www.tokoro.me/posts/visionos-simplest-full-immersion-space-app/</link>
      <pubDate>Thu, 28 Sep 2023 11:00:50 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/visionos-simplest-full-immersion-space-app/</guid>
      <description>ぼくがやりたかったのはシンプルに完全没入空間 immersiveStyle = FullImmersionStyle になにか表示するというだけなのですが、それなのに地味にはまったため記事にしています。
完全没入空間とは 日本語訳が正しいかわかりませんが、パススルー領域が全くない３６０度全面が1つのアプリで覆われた空間が完全没入空間です。
visionOSならではのUIであるため、なにかしら試してみたいかたも多いのではないでしょうか。
Appleのサンプルでは宇宙空間に没入するデモがあります。
最もシンプルなサンプルがほしい！ このAppleのサンプルを動かせばことが済む話でもあるのですが、このサンプルでも地球や月などのコンテンツを読み出してRealityViewに設置するなどしなければならず、RealityKitに慣れていない僕にとってはこれでも冗長かなあという感覚でした。
僕からすると未知のファイルなどがなにもなく、単に目の前に四角形が1つ出る程度の最もシンプルなものが欲しかったんです。
それをベースにちょっとずつ自分で実験をしていければ、と。
これが最低限の３ファイルだ！ app.swift アプリのエントリポイントです。
import SwiftUI @main struct SimplestFullImmersionApp: App { var body: some Scene { WindowGroup { ContentView() } ImmersiveSpace(id: &amp;quot;ImmersiveSpace&amp;quot;) { ImmersiveView() } .immersionStyle(selection: .constant(.full), in: .full) } } body内に初期表示される WindowGroup と ImmersiveSpace を置きます ImmersiveSpace は完全没入スタイルにするため immersionStyle に full を指定します ContentView.swift 初期表示されるWindowのViewです。
import SwiftUI struct ContentView: View { @Environment(\.openImmersiveSpace) var openImmersiveSpace var body: some View { Button(&amp;quot;Open Immersive Space&amp;quot;) { Task { await openImmersiveSpace(id: &amp;quot;ImmersiveSpace&amp;quot;) } } } } Environmentの openImmersiveSpace を使えるようにします Buttonを1つ設置し押したら openImmersiveSpace で app.</description>
    </item>
    
    <item>
      <title>[iOSDC Japan 2023] SharePlayの歴史と進化 - そしてvisionOSへ</title>
      <link>https://www.tokoro.me/posts/iosdc2023-shareplay/</link>
      <pubDate>Mon, 18 Sep 2023 11:37:41 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/iosdc2023-shareplay/</guid>
      <description>Photo by @huin
去る2023年9月1日に iOSDC Japan 2023 に参加し、 SharePlayの歴史と進化 - そしてvisionOSへ というセッションをもたせていただきました。
遅ればせながら iwillblog !
セッションスライドは 公開 しているものの、スライドにはあまり内容書いておらず台本がメインのため、以下、スライドを添付しつつセッションの内容を簡単にまとめます。
SharePlayってなに？ 2021年の発表時点ではFaceTime通話中に離れた場所の知り合いとアプリのコンテンツを共有するもの」と紹介していましたが、じつはこの2年でSharePlayの基本概念自体も大きく変わってきています。
まず2022年に「FaceTime通話中」という制限が撤廃され、2023年のiOS17では「離れた場所の知り合い」という前提条件もなくなり、むしろ積極的に近くの誰かとアプリを共有することを推し出すものとなりました。
SharePlayは、大きく3種に分けることができます。 Screen Sharing、Media playback、Custom UIです。
Screen Sharingは表示されているアプリの画面をそのまま共有する機能です。 Media playbackは動画や音楽を同期再生するものです。 Custom UIは各アプリで自由にイベントを送受信するためのものです。 Media playbackとCustom UIは各アプリに組み込が必要な機能で、この2つは同居できます。 SharePlayの歴史と進化 2021年にSharePlayが発表されました。しかしこの時点ではFaceTimeの通話中にしか発火できないという大きな制限がありました。
翌年2022年には、FaceTime通話中でなくても、アプリ手動でSharePlayを開始したり、さらにはiMessageをトリガーとしてFaceTimeを介さずにSharePlayをすることも可能になりました。 ただ、この時点でもFaceTimeかiMessageのどちらかが必要なので「連絡先を知っている相手」とのみSharePlayができると言う制限がありました。
そして2023年、SharePlayに革新的なバージョンアップがありました！
こちらはAppleのWebサイトのスクショですが「iPhone同士を近づけてAirDropできるようになった」という紹介とともに「iPhoneを近づけるだけでSharePlayが開始する」というSharePlayの新機能の紹介が押し出されています。
そうです！AirDropでSharePlayを開始できるようになったのです。
AirDropでSharePlayとだけ聞くと、ひょっとすると「AirDropでできるのちょっとだけ便利になったね」くらいの印象かもしれません。
しかし実際にはこれは 「連絡先を知らない相手」とも気軽にSharePlayが可能になった というSharePlayの歴史においては革新的なバージョンアップなんです。
これでSharePlayを利用開始する敷居は格段に下がりました。
また、AirDropするということはAirDropする相手がすぐ近くにいるということですので、これまで特にコロナ禍でリモートで離れた場所にいる家族や友達とのSharePlayという押し出しかただったのと比較し、2023年には「近くにいる知り合い」とのSharePlay！というのも大きく推し出されるように変わりました！
もっというとAirDropの採用は、連絡先を登録しあうまでではない知り合いとの インスタントなSharePlay がユースケースに加わったということを示しています。
その他のバージョンアップ まず、2022年 iOS15.4でSharePlayのカスタムUIで一度に送信できるメッセージのサイズが64KBから256KBに拡大されました。
次にiOS15.4でメッセージ送信のレイテンシを改善する機能も入っています。具体的には優先度の低いメッセージをアプリで明示的に指定し、UDPで高速に送信できるようにする仕組みです。
たとえばお絵描きアプリであれば、線を描いている途中経過については低レイテンシで高速にメッセージを送信し、線を全て描き終わったタイミングで線の全ての情報を改めて信頼性の高いメッセージで送信しなおす、といったことが可能です。
またiOS15.4ではアプリがSharePlayの開始を簡単に実現できるようにGroupActivitySharingControllerというクラスも追加されました。
これを利用することでアプリ手動でSharePlayを開始し、FaceTimeやMessageで友達をSharePlayに招待するUIをOS任せで簡単に実現できるようになりました。
そして2023年、iOS17でSharePlayの仕組みの中でファイル送信も可能になります！
これまでは画像やPDFなどの重いファイルをSharePlayの仕組みの中だけで送受信することはできませんでした。
iOS17からは、たとえばお絵描きアプリの写真やPDF添付機能もSharePlayの仕組みの中だけで完結できます。
さらに素晴らしいことにSharePlayのファイル転送の仕組みは、SharePlayに後から参加した人へのフォローもしてくれます。
通常SharePlayは後から参加した人に現在の状態を伝えるために、他の参加者がこれまでの経緯をまとめて送り直す必要があります。
しかしサイズの大きいファイルを送り直すのは大変です。SharePlayのファイル転送機能では、他の参加者が送り直さなくてもAppleのサーバから直接ファイルをダウンロードすることが可能とのことです。
そして最後に、tvOS17からはApple TVでもFaceTimeが可能になりました！
これ自体はSharePlayに関するアップデートではありませんが、マルチプラットフォームでSharePlayを扱いやすくなったという点で非常に良いニュースかと思います。
visionOSでのSharePlay とここまでSharePlayの歴史と進化について紹介してきましたが、今年2023年にはApple Vision Proも発表されました。 SharePlayは、もちろんvisionOSにも対応します。</description>
    </item>
    
    <item>
      <title>[visionOSアプリ練習] SwiftUIアプリで3Dモデルを表示する</title>
      <link>https://www.tokoro.me/posts/visionos-volume-3dmodel/</link>
      <pubDate>Mon, 26 Jun 2023 17:27:14 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/visionos-volume-3dmodel/</guid>
      <description>visionOS SDK Betaがリリースされましたので少しずつ勉強していきます！ まずは第一歩目としてSwiftUIアプリの中で3Dモデルを表示してみました。
どうやって表示する？ WWDCセッションの紹介としてはどうやらSwiftUIのViewで
Model3D(named: &amp;quot;xxx&amp;quot;) とするだけで表示できるようです。 簡単すごい！
どんな3Dモデルを表示できる？ https://developer.apple.com/documentation/realitykit/model3d/init(named:bundle:) によると
The name of the USD or Reality file to display.
USDファイル Realityファイル を読み込めるよう。
Realityファイルについてはよく知らないがApple独自のものっぽいです。
USDは Universal Scene Description といってピクサーの開発した3Dシーングラフ形式とのことらしい。
今回はどこかからUSDファイルをお借りして表示してみることにします。
使わせていただいたUSDファイル J CUBE Inc. - Maneki USDZ for AR / CC BY 4.0
ベースとなるSwiftUIアプリ マルチプラットフォーム対応のシンプルなSwiftUIアプリをベースとしました。
App import SwiftUI @main struct app: App { var body: some Scene { WindowGroup { ContentView() } .windowStyle(.volumetric) } } SwiftUIアプリはデフォルトではWindowタイプ（平面）になるため、3D表示するためのVolumeタイプにするため、WindowGroupに .windowStyle(.volumetric) モディファイアを適用しました。 変更したのはその1行だけです。</description>
    </item>
    
    <item>
      <title>WWDC2023 KeynoteのApple Pro Visionの紹介をとにかく細かく視聴してコメントしました</title>
      <link>https://www.tokoro.me/posts/wwdc2023-keynote-pro-vision/</link>
      <pubDate>Thu, 15 Jun 2023 15:11:44 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/wwdc2023-keynote-pro-vision/</guid>
      <description>タイトルのとおりですが、KeynoteのApple Pro Visionの紹介部分を見直して、一場面一場面停止して詳細を眺めつつ、感じたことを１つ１つ細かくコメントしていきました（3時間以上かかりました&amp;hellip;）。
留意事項 ソフトウェア面に注視し、ハードウェアの説明の部分はスキップしています あくまでも所が思ったこと感じたことをコメントしていくだけでエビデンス等はありません Keynoteを視聴しながら都度思ったことを時系列に書き込んでいますので検討外れなことを言ったりもします 視聴が進んでいく中で前半にコメントした疑問が後半で解決したり訂正されたりもしています イントロダクション ホーム画面 丸いアプリアイコンが並ぶ フォルダらしきものもある iPhoneのホーム画面のようにページをサポートしたりするのだろうか？ Spotlightやウィジェットなどの扱いは？ 左端に３つのモード？を切り替えるようなボタンがある １つはアプリモード １つは隣あった人のアイコン SF Symbolsでいうと person.2.fill なんらか人とコミュニケーションをとるためのモードか？ コミュニケーションがトップレベルに位置しているのがそこを重要視しているあらわれか １つは景色的なアイコン SF Symbolsで言うと mountain.2.fill に似ているが同じものは見つからず（それに星的なものが付いている） アプリ、コミュニケーションに並んでトップレベルに置かれるもの、なんだろう？ ARでなく全面を覆うVRモード的なものに入ったりする？ （と思ったが後にDigital Crownで現実と仮想の深度を調整できると紹介されていたので違いそう） 写真アプリ ウィンドウ内で写真のリストをスクロールするデモ ホーム画面にもあった左端のボタンリストが写真アプリに入って切り替わった おそらくこれがvisionOSにおけるタブバーだろう タブバーがホーム画面にも存在するというのはiOSなどではなかった 画面下部にはコンテキストのスイッチャー的なUIがある これはiOSの写真アプリにもあるものだが写真アプリのウィンドウから少し外れて表示されているのが特徴 おそらくiOS標準のUIコントローラを利用していればこのようにOSに合わせて良きように表示してくれるのだろう 可能な場面では標準のUIコントローラを利用するのがより重要になりそう さらにこの下に謎のドットとバーのUIがある バーはiOSだとドラッグ可能であることを示すUI これでウィンドウの場所を変更するなどできるのかもしれない その隣にあるドットもウィンドウをなんらか変更するUIかも？たとえばウィンドウを最小化するとか UI 目、手、声で操作する 重要視する操作方法の順番と思われる 目（Eye Tracking）が一番はじめにくるのが特徴か 360度？好きな位置にウィンドウを配置できるとのこと 「好きな大きさで」アプリを使うというキーワードもあった iOS/iPadOSではなかった複数のアプリが同時にフォアグラウンドにあるという状態がありそう もしくは注視している１アプリがフォアグラウンド扱いとか制御される？ ディスプレイサイズの制限はもちろんないのでアプリのUIデザイン（レイアウト）のしかたは大きく変わってくるのか？ アダプティブなレイアウト（ウィンドウサイズが柔軟に変わる）をサポートする知見は重要 ウィンドウが並ぶのでドラッグ＆ドロップなどアプリ間の連携を意識することもより重要になるだろう このスクショの画面をみるかぎり、真正面にないアプリにもフォーカスがあたっている 複数のアプリがフォアグランドになるか、視線があたっているアプリ１つがフォアグランドになるかのどちらかで確定っぽい この写真がグワっと拡大して没入モードになるところすごい いちおうウィンドウサイズのテンプレート的なもの（Normalサイズ、Expandサイズとか）はあるのかな？ この部分のトップバー的な位置に目を向けると、iOSではナビゲーションバーのleftButtonItem、rightBarButtonItemに配置される要素がある これは透明なナビゲーションバーなのか、それとも別の概念なのか なおKeynote内で他にもナビゲーションバー的なものの他のバリエーションが散見される これらがMacアプリだとこうなる、visionOSアプリだとこうなるみたいなアプリ種別によるものなのか もしくはアプリの状態やモードによるものなのか この場面には利用者本人が映っているのでイメージだろうが、映画やゲームで背景をコンテンツに合わせたものに差し替えるというのはありそう 映画視聴で背景を暗くするというのは後から具体的に説明があった これも利用者本人がいるのでイメージだろうが、FaceTimeなどでプレゼン資料と参加者の顔が空間内で横並びになっているのはリアルに近いミーティングができそうですごい Macがパーソナルコンピューティング iPhoneがモバイルコンピューティング そしてVision Proが空間コンピューティングを切り拓く！しびれる！ Vision Proを実際に使う体験 この画面は「ホームビュー」という名称で紹介されていた アプリの背景は透過されブラーがかかっていて角丸 このタブバー？はフォーカスされることで拡がり、アイコンのみ表示からタイトル付き表示に切り替わった このフォーカスされることで領域も内容も拡大される挙動はタブバーだけでなくアプリ全体の共通のUIのよう アプリのウィンドウの影が現実世界に投影されるのがすごい ウィンドウの右下隅のカーブ状のノブでウィンドウサイズが変更可能とのこと ふだんは表示されていないのでウィンドウの隅を注視すると表示されるのかもしれない ウィンドウ下のバー（ノブ）はウィンドウを動かすUIであることが確定 ここではZ方向に動かしているが、XY方向に動かせるかは不明 アプリ（ウィンドウ）を複数開くと自分（の真正面？）を中心に自動的にスペースが割り当てられるとのこと この場面では、アプリが２つの場合は真正面にどちらか一方がくるのではなく真正面の左右にそれぞれが配置されていた アプリ主動で背景（現実世界）部分を暗くしたりのカスタマイズができるというのも確定で良さそう 現実世界 OR 仮想世界の境界（深度）はデジタルクラウンで任意で調整できるとのこと ２択でなく曖昧にでき、ハードウェアでいつでも？調整できるというのが素敵 視線を向けた部分にフォーカスが当たるというので確定っぽい アプリアイコンはフォーカスが当たると分解されて一部が浮き上がっている！ ということはアプリアイコンをそういう作りにできる（することが推奨される）ということ アプリアイコンのレイヤー分けはtvOSアプリ用のアイコンで既に採用されている フォーカスがあたっている要素を選択するのは「２つの指同士をタップ」 スクロールは「２つの指を上下にずらす」 検索フィールドに視線を合わせたら「声で検索キーワードを入力できる」とのことだが、声を使うのは最後の手段だろうなという印象 複雑なURLやパスワードを打つのは大変そうだから基本的には文字入力はさせないことをベースに考えるのだろう いっぽうで既にAppleTV+iPhoneの連携でtvOSの画面のパスワードをiPhoneで入力という機能は実現されているし、visionOSでも物理キーボードが使えることが明示されているので、複雑な文字入力が必要な場面があっても問題はないだろう EyeSight 装着車の目がゴーグルの前面のディスプレイに表示されるとのこと（見た目はちょっと不気味の谷 ゴーグル装着者を周りから孤立させない（逆もまた然り）という考え方は素敵 EyeSightも「近くに人がいる時は」というトリガーなので良さそう アプリを使っているとき、没入モードのときなど装着者の状態を周りの人が判断できるようになっているのもすごい 装着者目線だと没入モード時に近くに人が来たら自動的に背景が透けてその相手が見えるとのこと 実際の使用感 Vision ProはiPhone/iPad/Macと常に同期 iCloudで常に同期（これは既存にもあるので特別ではない） 真ん中にSafari、左右に別のアプリがある状態で「Safariを拡大」した時はこうなる 拡大（Expand）モード的なものがあり、そのモードになると他のウィンドウは見えなくなるっぽい visionOSのナビゲーションバー（トップバー）はこのコンテンツウィンドウから離れた場所に表示されるものが基本っぽい ここでアプリのウィンドウは「前後にも上下にも積み重ねられる」ことが明示された アプリ内の要素のドラッグ＆ドロップができることも明示 しかも他アプリだけでなく現実世界へのドロップ！ メッセージで届いた3Dオブジェクトを現実世界の机の上におけるのすごい もちろんMagic TrackpadやMagic Keyboardも使える Bluetoothアクセサリ&amp;hellip;と紹介されていたので、ぼくのHHKBもきっと使えるはず あとはこれがすごすぎる 現実世界のMacを見つめるとMacのスクリーンがVision Proのほうに映るとのこと もちろんVision Proのアプリと並列に並ぶ iPhoneやiPadもそうなるのかな？ これはApple製品にどっぷりつかる理由になるな（もう既にどっぷりつかってるけど） リモートで同僚と同じ書類を使いながらの共同作業が&amp;hellip;とあるが、これはvisionOSではじまったものではなく既存からあるもの こういった共同作業サポートがスタンダードになったら嬉しいがアプリ開発の難易度は確実に上がる&amp;hellip; この場面ではアプリが上下に並んでいる実例が このFaceTimeでのミーティングの風景 プレゼン資料が投影されているがこれがSharePlayであることが明示された そのため、SharePlay対応していればサードパーティアプリでもこのような使い方ができるはず そもそもiOSの画面共有もSharePlayなのでなにも対応してなくても自分のアプリをここに投影できる可能性が高い 今考えるとSharePlayがFaceTimeと密結合なのはこのVision Proでの利用を見据えてだったのかもな、と 家での体験 アプリ手動で背景（現実世界）をいじれることを再確認 この場面はパノラマ写真をパノラマ表示したものだったようだ Vision Proでは3Dカメラによる空間再現写真・ビデオの撮影が可能 もちろん空間再現写真・ビデオを視聴することもできる 映画視聴のときは、フッド山などの環境を開いて（おそらく背景に奥行きのある壮大なものを選ぶのが良いということかと）スクリーンを拡大するのがおすすめとのこと もちろん背景は自動的に暗くなる 空間オーディオの品質が高いのはお墨付きだし映画視聴良いかもな もし視聴中に家族がきて声をかけられても、自動でそれを検知して家族の姿が見えて声も聞こえるようになるのがvisionOSのすごいところ Apple TV+だけでなく他の動画視聴サービスにも対応しているとのこと 標準のAVPlayer使っていれば対応してくれるのだと予想 3Dムービーにも対応 アバター２をこれで視聴してみたい 恐竜がウィンドウからXYZ全方向にもはみ出してるのもすごい Apple Arcaceのゲームを遊べるという件は&amp;hellip;コンテンツ次第か ウィンドウに収まらない３Dのゲームとか出たら体感的にはすごそう それよりもNintendo SwitchのゲームをVision Pro経由で遊びたいですね ウォルト・ディズニー Kyenoteでウォルト・ディズニーが登場して、コンテンツが揃っていることを（目標にしている）前面に押し出しているのを感じる コンテンツと一緒に背景も配布してくれるみたいのがあるのかも スポーツ観戦でさまざまな付加情報が表示されたり あとは複数のカメラの映像が同時に表示されていて、おそらく視線を向けたカメラに切り替わるだろうUIになっているのが興味深い ミッキーが自分の部屋に降臨！ ディズニーでなくても、自分の好きなキャラクターが自分のそばにいて動いて喋ってくれるのは喜ぶ人たくさんいそう 現実世界の自分の腕にブレスレットが装備される場面 こういう現実世界とかけあわせたコンテンツはVision Proならではの体験になりそうか 後から出てくるがこういうアプリを「空間対応アプリ」と呼ぶよう ハードウェア （ハードウェアの部分は基本スキップします。気になったところだけスポットで。）</description>
    </item>
    
    <item>
      <title>potatotips #74 で「5分でSharePlay入門」のLTをしました</title>
      <link>https://www.tokoro.me/posts/potatotips-74-shareplay/</link>
      <pubDate>Mon, 28 Jun 2021 13:29:12 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/potatotips-74-shareplay/</guid>
      <description>potatotips #74 2021年6月23日（水）にWantedlyさんご主催のオンラインpotatotips（iOS/Android開発Tips共有会）が開催されました。
イベントページ 当日のLT一覧 私はpotatotipsの運営窓口を担当しているのですが、今回はひさびさにLTもさせていただきました。
LTの内容は「5分でSharePlay」です！ スライドは コチラ。
今回は、このLTの内容をこちらにブログ記事としてまとめさせていただきます。
SharePlayとは？ SharePlayとは、FaceTime通話中に離れた場所の友達とアプリのコンテンツを共有する機能です。 このスクショは離れた場所にいる2人が不動産アプリを一緒に見ながら新しい家の候補を決めている様子です。
利用シーン SharePlayの利用シーンは様々です。 WWDC21の各セッションの中でも様々なシーンが紹介されています。
一緒に映画やスポーツを視聴する ゲームのスーパープレイを自慢する 旅行のときの写真を友人や家族と一緒に見る グループでお絵描きする Swift Playgroundsで一緒にSwiftを学ぶ 不動産アプリで新しい家の候補をふたりで探す 実家の両親がアプリの使い方がわからないのをサポートする 3種のSharePlay SharePlayには大きく3種あります。
Screen sharing: 画面共有 Media playback: 動画や音楽の共有 Custom UI: カスタム ※カスタムについてはこの記事では紹介しませんが、デバイス間でカスタムなコマンドを自由に送受信できる柔軟な仕組みがあります
画面共有への対応 SharePlayの画面共有に対応するには各アプリでどの程度の実装が必要でしょうか？
じつは各アプリでの対応は必要なく、なにもしなくても画面共有に対応できます。 正確には画面共有はホーム画面ごと共有され、その時開いているアプリの画面もそのまま共有されます。
自動的に隠される要素 画面共有は自動的にされる（されてしまう）のですが、一部、共有されない要素があります。
パスワードなどセキュアな入力フィールド DRM（FairPlay）で保護されたコンテンツ です。 その他、必要なら各アプリで隠したい要素（View）をカスタムすることもできます。
動画の共有への対応 最後に動画の共有への対応についてです。
AppleのTVアプリの例 AppleオフィシャルのTVアプリでは次の手順で動画のSharePlayを開始できます。
まず、FaceTime中にTVアプリを起動すると、コンテンツ表示部分に SharePlayが可能であることを示すアイコン が表示されます。
このとき動画を再生しようとすると、 SharePlayするかどうかを確認するダイアログ が表示されます。 ここで SharePlay を選べば動画のSharePlayの開始です。
動画のSharePlayでできること 動画のSharePlayをすると、
DRMで保護されたコンテンツの共有 再生・停止・シークなどによる再生位置の同期 などがデフォルトでサポートされます。
動画のSharePlay対応に必要なコード 実際に動画のSharePlayに対応してみた ViewController のコードが以下です。
import AVKit import GroupActivities import UIKit class ViewController: AVPlayerViewController { private var groupSession: GroupSession&amp;lt;MovieWatchingActivity&amp;gt;?</description>
    </item>
    
    <item>
      <title>[WWDC21] [SharePlay] Meet Group Activitiesのまとめ</title>
      <link>https://www.tokoro.me/posts/wwdc21-meet-group-activities/</link>
      <pubDate>Thu, 10 Jun 2021 12:56:44 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/wwdc21-meet-group-activities/</guid>
      <description>Meet Group Activities を視聴して内容をまとめたものです。
先に簡単にまとめ SharePlayはiOS、iPadOS、tvOS、macOSの全てで利用できる ビデオや音楽のShareはmacOSのブラウザでも利用できる SharePlayは大きくは「ビデオや音楽のShare」「その他のカスタム体験のShare」の2つに分けられる ビデオや音楽のShareは、再生、一時停止、シークなどによる再生位置の変化が同期される カスタム体験のほうは一緒にお絵描きさせるなどだいぶ柔軟性がありそう ビデオや音楽のShareはAVPlayerを使えば簡単に実現できるが、独自のプレイヤーを実装していても実現するすべがある アプリごとに自由に独自のイベントを送受信すること可能 導入 離れた場所にいる人たちと同じ部屋にいるような感覚でアクティビティを楽しめる新しい方法として SharePlay は開発されました。
SharePlayは、GroupActivities フレームワークによって実現されています。
このセッションでは、サードパーティアプリにSharePlayを採用する方法が紹介されています。
Communication Appleは、スムーズに自然なコミュニケーションができることが最重要であると考え、FaceTimeとMessagesにSharePlayを組み込んでいます。
ユーザーは、自分にとって最も身近な人たち、友人や家族とのコミュニケーションにかなりの時間を費やしています。 それらは、映画を見るためにリビングルームに招待する対象となるような人たちです。
SharePlayで促進したいのは、まさにそのような人たちとの体験の共有です。
Session SharePlayには、Sessionという概念があります。 Sessionを開始すると、ユーザーはいつものMessagesやFaceTimeで、テキスト、オーディオ、ビデオを使ったコミュニケーションができるようになります。 ユーザーはSessionの中でこれらを柔軟に切り替えられます。 開始済みのSessionに新しい人を招待したり、Sessionの途中で離脱もできます。
SessionをOSが管理してくれるため、ユーザーはSession中でもあらゆるアプリを利用することができます。
各アプリの開発者は、Group Activitiesを使えば、これらの機能を全て利用できます。
Platform Group ActivitiesはiOS、iPadOS、macOSの全てに同じ体験を提供できます。 それだけでなくWebサイト（WebKitブラウザ）でも利用できます（後からmacOSではという言及もあったので要調査）。 Apple TVでも動作するので、大画面のテレビでも楽しめます。
Sessionにはどのデバイスからも参加できますし、複数のデバイスをシームレスに使うこともできます。 AirPodsをはじめとするBluetoothデバイスにも素晴らしいオーディオを提供できるように設計されています。
Playback 共視聴体験のトリガーになるのは、再生ボタンです。 ユーザーがどのコンテンツに時間を費やすかを決める瞬間です。
Appleは、すべての再生ボタンがSharePlayと連動することを目標としています。 ユーザーが友達とFaceTimeで話しているときに、アプリ内のメディアをいつでもSharePlayできるようにしたいと考えています。
各アプリが簡単にSharePlayできるよう、既存のコードそのままで使えように設計したAPIを提供しています。 グループで会話をしているときにいつでも、各アプリの再生ボタンからSharePlayを開始できるようになります。
Time-Synced Playback SharePlayでは、再生の同期が可能です。 誰かが再生ボタンを押すと、グループ全員のデバイスで同時に再生が開始します。 お気に入りのシーンにジャンプすれば、他の全員にもそのシーンが表示され、まるで同じ部屋にいるかのように体験することができます。
この同期は、手元のメディアを再送信することで実現しているわけではありません。 各々のデバイスに直接ストリーミングされ、各デバイスでの最高品質のメディアを再生できます。
スマートボリューム 再生中に誰かが発言すると、コンテンツの音量が自動的に下げられ、同じ部屋にいるようにコミュニケーションをとることができます。
Picture in Picture Picture in Pictureとの相性も抜群で、PiPによりコンテンツを視聴しながら他の様々なアプリを利用することができます。
Content FaceTimeで通話中のユーザーは、各アプリを起動したとき、そのアプリのコンテンツを共有できることを期待するようになります。
SharePlayにより、各アプリのタッチポイントを拡大し、アプリにかかわる時間を増やすことができます。 既存ユーザーが友達とSharePlayをすることで、自然にあなたのアプリを広めてくれることでしょう。
Group Activities Group Activitiesはフレームワークのコアコンセプトです。 Group Activitiesは、FaceTimeでSharePlayをして楽しむ対象（オブジェクト）です。</description>
    </item>
    
    <item>
      <title>WWDC21 Keynote iOS 15についての発表の復習</title>
      <link>https://www.tokoro.me/posts/wwdc2021-keynote/</link>
      <pubDate>Tue, 08 Jun 2021 17:50:33 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/wwdc2021-keynote/</guid>
      <description>iOS 15 2021年6月8日、WWDC21のKeynoteでiOS 15についての発表がありました。
iOS 15だけでも盛りだくさんな内容でしたので、Keynoteをもう一度見直し、1つ1つ確認しながらメモをして復習してみました。
これから詳細なセッションもどんどんと公開されますので、これをインデックスに興味を持った新機能のセッションにダイブしていこうと思います！
FaceTime Spatial audio 空間オーディオ。 自然に感じられるようビデオ通話画面の各メンバーが映っている方向から音声が聞こえてくるように表現される。
Voice isolation 声を分離。 周いの騒音を遮断できる。
周りの音も拾いたければワイドスペクトラムに設定することで可能。
Grid view 全員の顔をグリッド表示する新しいレイアウト。
Portrait mode ポートレートモード。背景をぼかし、あなたの顔に自然に焦点が合うように。
FaceTime links FaceTimeの通話に招待するリンクを作成し、どのツールででも共有できる。リンクを事前に作ってカレンダーに登録しておくなども可能。
AppleのデバイスでだけでなくAndroidやWindowsでもブラウザ経由で参加可能！
FaceTimeはEnd-to-endで暗号化されておりプライバシーが損なわれることもない。
SharePlay 体験を共有する。 FaceTime中に楽しめる。 例えば通話中に音楽を流して一緒に聴いたり、映画やテレビ番組を観ることもできる。 その他のアプリも画面共有が可能で無限の可能性がある。
音楽 SharePlayで音楽を同期再生している間、誰でも再生待ちリストに曲を追加でき、再生や一時停止、次のトラックへのスキップもできる。
映像 FaceTime中にアプリで映像を再生すると、通話中の友達と同じビデオを同期した状態で観ることができる。
映像を同時視聴している間も通話は続くし、他のアプリを起動してテイクアウトを注文、なども可能。 その間もピクチャ・イン・ピクチャでビデオと友達の顔の両方が見える。
PiPをタップすることでSharePlayのコントロールが表示される。
同時視聴中のビデオをAppleTVでAirPlayし、テレビの大画面で再生することもできる。
SharePlay API SharePlay APIによりサードパーティ製アプリもFaceTimeに組み込むことができる。
Disney+ Hulu HBO Max NBAアプリ twitch TikTOk MasterClass ESPN+ Paramaount+ Pluto TV などが既に対応を進めている。
Screen sharing 画面共有。 将来のルームメイトと一緒に不動産アプリで物件を閲覧したり、ゲームの画面を共有したり、画面共有して困っている人を助けたり。
Messages コラージュデザイン 新しいコラージュデザイン。スワイプで写真をめくったりタップして全部の写真を見たりできる。
Shared with You あなたと共有。</description>
    </item>
    
    <item>
      <title>スーパー楕円UIをiOS&#43;Swiftで実装する</title>
      <link>https://www.tokoro.me/posts/swift-superellipse/</link>
      <pubDate>Fri, 29 Jan 2021 15:04:26 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/swift-superellipse/</guid>
      <description>弊社デザイナーの @kudakuarge が スーパー楕円に関する良記事 を投稿していました。
スーパー楕円は最近話題になっているClubhouseでも使われているとのこと。
そのため便乗してiOS+Swiftでスーパー楕円UIを実装してみます。
どう実装する？ iOSアプリの上で上にUIImageViewとか様々なViewをのせるような使い方をすることになりそうですので、基本的にはUIViewのサブクラスである必要がありそうです。
スーパー楕円を表示（描画）するだけならUIBezierPathなどでスーパー楕円を作って UIViewのdrawメソッド をオーバーライドしてfillするなどで良さそうです。
しかし、上のUIImageViewなどをのせて、上にのせたViewも一緒にスーパー楕円でマスクされないといけないので、 CALayerのmask でスーパー楕円の形にマスクすべきかもしれません。
スーパー楕円はどう作る？ 上の記事 にJavaScriptのサンプルコードがありますが、これはベジェ曲線での描画ではなく、スーパー楕円を構成するドットの配列を作る例のため、今回の用途にはアンマッチです。
ただ、同じ記事の後半でFigmaやSketchなどのツールで円形からアンカーポイントを移動させてスーパー楕円を作る例が紹介されていて、おそらくこの例のように4つのベジェ曲線を使い、アンカーポイントを調整することでスーパー楕円が作れるだろうということが予想できました。
実装例 ということで、まずはUIBezierPathでスーパー楕円を作ってみます。 引数で渡した四角形（CGRect）に沿って、4つのベジェ曲線を追加しているだけです。
引数kでアンカーポイントの位置（結果としてスーパー楕円の丸み）を調整できるようにしています。
import UIKit public struct Superellipse { public let bezierPath: UIBezierPath public init(in rect: CGRect, k: CGFloat) { let path = UIBezierPath(ovalIn: rect) let handleX: CGFloat = rect.size.width * k / 2 let handleY: CGFloat = rect.size.height * k / 2 let left = CGPoint(x: rect.minX, y: rect.</description>
    </item>
    
    <item>
      <title>Gitのcommitメッセージをその場で英訳したい！</title>
      <link>https://www.tokoro.me/posts/commit-message-inline-translation/</link>
      <pubDate>Thu, 17 Dec 2020 11:22:39 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/commit-message-inline-translation/</guid>
      <description>完成後に収録した画面 対象者 Vimでコーディングしている人 Vim以外でコーディングしてるがgit commitのときだけVimが起動する人（macOSだとデフォルトでそうなります） ぼくの課題 git commitでcommitメッセージを書く時、英語で書くことが多いと思います（プロジェクトによるとは思いますが）。
ぼくは英語でcommitメッセージを書くのが得意ではなく「あの不具合をこんな感じに修正したんだよなあ、それを英語で書くと&amp;hellip;」と考えつつ面倒になってFix a problemとか意味のないcommitメッセージを残してしまうことがありました。いちばんひどいときは.とか&amp;hellip;。ごめんなさい。
しかし昨今はDeepLなど優秀な翻訳サービスがあるわけですし、それを使えば良いだけじゃんは思うものの、実際にgit commitした後に翻訳サービスを開いてそこに日本語を入力して、翻訳結果をコピーしてエディタに戻ってきてペーストする、というのが日々のコーディングの流れの中では面倒すぎてけっきょくFix a problemとしてしまうわけです&amp;hellip;
解決案 それを解決するのは簡単で、git commitで開かれたエディタで入力した日本語がその場で英訳されれば良い、というだけです。
技術的にも英訳APIが使えればすぐにでもできる話ですので、先日、半日程度時間が作れるタイミングでやってしまおう、となったというお話です。
作る 翻訳API 愛用しているDeepLにAPIがあったのでそれを使います。
https://www.deepl.com/docs-api/translating-text/request/
APIの利用はとても簡単で、テキストの翻訳なら、
curl https://api.deepl.com/v2/translate \ -X POST \ --data &#39;auth_key=AUTH_KEY&amp;amp;target_lang=EN-US&amp;amp;text=おはよう&#39; とするだけでとても簡単です。
英訳コマンド 今時点ではDeepLにCUIコマンドがないため、上の翻訳APIを叩くコマンドを自分で作ります。
といっても上のPOSTリクエストを1つ叩くだけなのですぐできます。
エディタから使いやすいように、
STDIN（標準入力）から翻訳したいテキストを受けて STDOUT（標準出力）に翻訳後のテキストを返す のが良さそうです。
ぼくがSwiftで書いたのが、
https://github.com/tokorom/deepl-cui-swift
です。 ここは誰かが作ったのを使ってもいいし、自分で作ってもすぐできるかと思います。
git commitから呼び出す この記事ではgit commitで起動するエディタがVimであることが前提です（macOSではデフォルトです）。
Vimからツールを呼ぶということはpluginを入れる必要がある？と思いがちですが「選択したテキストを外部コマンドに渡して結果と置き換える」というのはVimが標準で備ている機能です。
具体的には!lsとコマンド実行すればVimにlsの結果が挿入されますし、JSON文字列を選択して!jq .でjqコマンドに選択範囲を渡して整形してもらった結果で置き換えるといったことが普通にできます。
今回は、STDINを英訳するコマンドを作ったので（deepl-cui-swiftコマンドとする）、翻訳したいテキストを選択して
!deep-cui-swift を実行するだけでこれが実現できます。
ショートカット 必要なら.vimrcにショートカットキーを用意しましょう。ぼくは、
nnoremap ze &amp;lt;S-v&amp;gt;!deepl-cui-swift -s JA -w&amp;lt;CR&amp;gt; とzeで現在行を英訳コマンドに渡す（ついでに翻訳前の言語を明示して、翻訳前のテキストも結果に含めるオプションを指定）ショートカットを用意して使っています。
動作確認 これでgit commit後のエディタで日本語でメッセージを書き、zeするだけで英訳されるようになりました！
ワイワイ！
オマケ DeepL APIの料金 なお、DeepL APIは無料で使えるわけではありません。</description>
    </item>
    
    <item>
      <title>iOS14で戻るボタンのタイトルを空欄にするきちんとした方法</title>
      <link>https://www.tokoro.me/posts/ios14_blank_back_button/</link>
      <pubDate>Mon, 26 Oct 2020 17:02:15 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/ios14_blank_back_button/</guid>
      <description>先にまとめ if #available(iOS 14.0, *) { navigationItem.backButtonDisplayMode = .minimal } else { navigationItem.backButtonTitle = &amp;quot; &amp;quot; } でOK！
概要 iOS14のアップデートの1つに、
ナビゲーションバーの戻るボタンを長押しすると、画面遷移のヒストリーが表示され、いくつか前の画面までいっきに戻ることができる というのがありますよね。
ユーザー目線ではたいへん便利な機能ですが、例えば、デザイン的に「戻るのタイトルを空欄」にしていたりすると、
と、この長押し時の戻り先リストも空欄になってしまうなどの問題が出てきます。
iOS13以前の方法 iOS13以前では、例えば、
Xcodeで該当画面（戻り先の画面）のNavigation ItemのBack Buttonに空白を1つ入れるなどして、戻るのタイトルを消すワークアラウンドがありました。
しかし、これをすると、iOS 14以降では長押し時の戻り先リストがおかしくなってしまうわけです。
iOS14でのきちんとした方法 そのため、まずiOS14ではBack Buttonの設定はいじらないようにしましょう1。
そうすると当然、
このように戻るボタンのところに画面名が表示されてしまいます。
そのうえで、iOS14から追加されたUINavigationItemのbackButtonDisplayModeを設定します。
https://developer.apple.com/documentation/uikit/uinavigationitem/3656350-backbuttondisplaymode
戻り先のUIViewControllerで、
if #available(iOS 14.0, *) { navigationItem.backButtonDisplayMode = .minimal } else { navigationItem.backButtonTitle = &amp;quot; &amp;quot; } と navigationItem.backButtonDisplayMode に .minimal を設定することで、戻るボタンのタイトルが非表示になります。
また、Back Buttonなどもいじっていないため、戻るボタン長押し時の戻り先のリストも、
のようにきちんと表示されます。
UINavigationItem.BackButtonDisplayMode なお、backButtonDisplayMode には以下の３種の値を設定できます。
BackButtonDisplayMode 挙動 default デフォルト値はこれで従来の挙動。具体的には画面のスペースに応じて「前画面のnavigationItem.backButtonTitle」「前画面のtitle」「Back（戻る）」「空欄」の優先順位でいずれかが表示される generic スペースがあれば「Back（戻る）」を表示、なければ空欄 minimal 常に空欄 例えば、先ほどの画面にgenericを設定した時のサンプルはこちらです。</description>
    </item>
    
    <item>
      <title>iOSDC Japan 2020でHomeKitについてのセッションで登壇しました #iwillblog</title>
      <link>https://www.tokoro.me/posts/iosdc2020/</link>
      <pubDate>Tue, 06 Oct 2020 14:57:02 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/iosdc2020/</guid>
      <description>2020年9月に開催された iOSDC Japan 2020 今年も盛り上がりましたね！ 2020年は初のオンライン開催でオフラインにはない良さも再認識することができました。
私も HomeKit 2020 というセッションで発表者として参加しました。
概要 セッションの概要はこんな感じです。ご興味がある題材がありましたら是非セッションビデオをご覧ください！
HomeKit Frameworkざっくり入門 HomeKit Frameworkでどんなことができるのか HomeKitの構成 具体的に電球を点灯させるコードの紹介 隠しキャラクター（HomeKitがサポートしていない気圧）を参照するテクニック HomeKitだからこそできる具体例 時間指定でなく「日の入」「日の出」をトリガーに 家に「誰もいなくなったら」をトリガーに 自動点灯したライトをN秒後に消灯する 「部屋が明るければ」自動点灯させない HomeKitのBridgeについて Hueには電球、人感センサー、スイッチなどあるが直接HomeKit対応しているのはじつは&amp;hellip; オープンソースのソフトウェアBridge「Homebridge」 HomebridgeでHomeKit未対応製品をHomeKit対応 ルンバ、スマートロック、赤外線リモコンなどもHomeKit対応できる！ Homebridgeを利用する具体的な方法　プラグインの自作 HomeKit ADKで作る自作アクセサリ HomeKit ADK概要 Homebridgeとの違い ソフトウェアでHomeKit対応アクセサリーを作る！ セッションビデオ スライド HomeKit入門の無料公開 iOSDC 2020とほぼ同時に、ちょうど良いタイミングでZennというサービスが始まり、Web上で簡単に書籍を執筆・公開できるようになりました。
そのため、かねてよりどこかで公開しようと思っていた『HomeKit入門』1 をZennで無料公開しました。
https://zenn.dev/tokorom/books/homekit-framework
iOS 11リリース当時に執筆したものですが、HomeKit FrameworkにはiOS 12以降大きな変更は入っていませんので、現在でも十分有効な内容かと思います。
ご興味ありましたら是非ご参照ください！
iOS 11 Programmingの第12章に掲載したものです https://peaks.cc/books/iOS11&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description>
    </item>
    
    <item>
      <title>自宅のインターネット接続環境を改善して通信速度を30Mbpsから400Mbpsにした経緯</title>
      <link>https://www.tokoro.me/posts/improve-my-internet-connection/</link>
      <pubDate>Mon, 07 Sep 2020 16:56:36 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/improve-my-internet-connection/</guid>
      <description>Photo by Franck V. on Unsplash
改善のきっかけ 自宅のインターネット接続環境は、改善前は通信速度が 10Mbps〜40Mbps 程度でした。
これで特に不満もなく使っていたのですが、同じプロバイダーを使っている同僚の @kudakurage が
「IPv6にしてWi-Fiルーターをいいやつに変えたら500Mbps以上出るようになったよ」
と教えてくれたので、 絶対に負けてられない！ せっかくなので自分も改善してみよう！ と思ったのがきっかけです。
前置き 私はネットワークに関する専門的な知識を持ち合わせていないため、おかしなことを書いたりしているかもしれません。
間違いなどありましたらよろしければ Twitter までご連絡ください。
以下、速度計測は全て Fast.com で実施しています 以下、速度計測は全て無線接続で実施しています 有線接続では計測していません Wi-Fi 6での計測はiPhone 11 Proを利用しています 改善前の状態 Key Value 通信速度 10〜40Mbps プロバイダー Interlink ZOOT NEXT IP IPv4 接続方式 PPPoE LANケーブル CAT6のフラットケーブル Wi-Fiルーター Apple AirMac Time Capsule Wi-Fi規格 Wi-Fi 5 (11ac) 上で同僚と同じプロバイダーと書きましたが、正確には「IIJmioひかり」と固定IP用に「Interlink ZOOT NEXT」の2つのプロバイダーを契約しており、同僚は「IIJmioひかり」を常用していて私は「Interlink ZOOT NEXT」を常用していました。というのに後から気づいたため、はじめはInterlinkのほうで計測しています。IIJmioのほうに切り替えても速度はそれほど変わらなかった記憶があります。
LANケーブルだけ変えた後 せっかくなのでいっきに全部変えてしまうのでなく、１要素ずつ変更して速度計測することにしました。
まず一発目に「これは効果はないだろうなあ」と思いつつも、LANケーブルだけ新調しました。 光回線の終端装置（ONU）とWi-FiルーターをつなぐLANケーブルです。
LANケーブルを新しいものに変えて計測したところ&amp;hellip;
いきなり最大 130Mbps まで速度が跳ね上がってしまいました。</description>
    </item>
    
    <item>
      <title>apple/swift-formatをVimで使う</title>
      <link>https://www.tokoro.me/posts/vim-swift-format/</link>
      <pubDate>Mon, 17 Aug 2020 18:11:06 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/vim-swift-format/</guid>
      <description>皆々様におかれましては apple/swift-format を快適にご利用いただいていますでしょうか？1
swift-formatをXcodeのBuild Phasesに設定して利用したり、CIなどで利用されているかたも多いかと思います。
私もswift-formatを利用しはじめたのですが、私のメインエディタであるVimからswift-formatを利用するといった記事は今のところ見つかりません。 iOSアプリをVimでコーディングするプログラマーは希有ですのでそれもしかたがないことでしょう。
ということでVim+SwiftでiOSアプリを開発して6年（2020年8月現在）の私がこの記事を書くこととしました。
swift-formatを扱うVim Pluginの存在 2020年8月現在、残念ながらswift-formatを扱うVim Pluginは見つかりませんでした。これまで利用されていたSwiftLintやSwiftFormatのPluginは見つかるのですが、新しめなapple/swift-format用のものはないようです。
そのため、Pluginといっても大した機能は必要ないこともあり、自分で作ることにしました。
https://github.com/tokorom/vim-swift-format
事前に必要なもの swift-format とうぜん事前にswift-formatが必要です。
which swift-format などで存在を確認してください2。
なければ現在ならbrewでもインストール可能です。
SwiftFormatというのは別のツールですので間違わないようご注意ください。
brew install swift-format aleというVimのPlugin https://github.com/dense-analysis/ale
非同期にLintをかけるためのPluginです。
今回、swift-formatによるLintはこのaleを経由してかけるように作っています。
vim-swift-formatのセットアップ Vimへのインストール ご利用のプラグインマネージャなどでインストールの設定をしてください。例えばVim-Plugなら
Plug &#39;tokorom/vim-swift-format&#39; です。
必須の設定 swift-formatによるLintをかけるにあたって以下の設定項目が必須です。.vimrcなど任意の場所に設定してください。
let g:ale_linters = { \ &#39;swift&#39;: [&#39;swift-format&#39;], \} let g:vim_swift_format_use_ale = 1 必要なら可能な設定 swift-formatの場所をフルパスで指定したい場合などは必要に応じて、
let g:vim_swift_format_executable = &#39;swift-format&#39; let g:vim_swift_format_lint_command = &#39;swift-format lint %s&#39; let g:vim_swift_format_format_command = &#39;swift-format format --in-place %s&#39; これらの設定が可能です。</description>
    </item>
    
    <item>
      <title>iOSアプリの本番環境でのテストをプロモーションコードを使って行うマニュアル</title>
      <link>https://www.tokoro.me/posts/ios-promocode/</link>
      <pubDate>Tue, 21 Jul 2020 11:48:23 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/ios-promocode/</guid>
      <description>Photo by JJ Ying on Unsplash
これは、プログラマー向けではなく、社内や社外のテスト担当者さん向けのマニュアルとして作成したものです。
2020年7月現在のApp Store Connectを使って、スクショ多めで具体的な操作方法をまとめます。
プロモーションコードの用途 公式な用途 プロモーションコードの用途ですがAppleのドキュメントでは、
報道関係者やインフルエンサーがAppのApp内課金をいち早く利用できるようにするため
とプロモーション用であることが説明されています。
リリース前のテスト用途 この他、アプリ開発者の間では、リリース前に
App Storeに公開されるアプリと全く同じものをテスト するためにも使われています。
プロモーションコードを使わなくてもTestflightによりほとんどのテストは可能ですが、場合によっては、
Testflightでのテスト時にはテストの効率化のためのデバッグ機能を入れていて、App Storeで公開するアプリのみデバッグ機能を除外している Testflightでのテストだと購入のテストにAppleのSandbox環境が使われてしまうが、どうしてもProduction環境での購入テストをやっておきたい などの理由により アプリをApp Storeで公開する前の最終テスト として利用できます。
プロモーションコードを発行できる条件 プロモーションコードは 審査が通って公開が可能な状態 のアプリに対してのみ発行できます。
そのため、App Storeで公開する前にプロモーションコードでのテストをしたい場合、
アプリを審査に出す際に「このバージョンを手動でリリースする」を選択しておく 審査に通ったらプロモーションコードを発行してテストする テストが完了したら「このバージョンをリリースする」ボタンでアプリをApp Storeに公開する という手順を踏む必要があります。
プロモーションコードの発行手順 App Store Connectにログインする https://appstoreconnect.apple.com/ にログインします。
Q. アカウントがないのでログインできません
A. 担当のかた or アプリの開発者に問い合わせてアカウントをもらってください
ログインしたら マイApp をクリックして プロモーションコードを発行する対象のアプリ を開きます。
プロモーションコードのページを開く アプリのページを開いたら画面上側の 機能 を選択し、画面左側の プロモーションコード を選択してプロモーションコードのページを開きます。
このページでプロモーションコードの発行や、過去に発行したコードの履歴を確認できます。
プロモーションコードを発行する プロモーションコードのページの Appプロモーションコード セクションがアプリのプロモーションコードを発行するためのセクションです。
ここの一番右の数量のフィールドに 1 を入力します。もし複数のプロモーションコードを一度に発行したい場合はその数を入力してください。</description>
    </item>
    
    <item>
      <title>iOSアプリの購入テストでSandboxアカウントを作って使うマニュアル</title>
      <link>https://www.tokoro.me/posts/ios-sandbox/</link>
      <pubDate>Wed, 08 Jul 2020 15:41:47 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/ios-sandbox/</guid>
      <description>Photo by Markus Spiske on Unsplash
これは、プログラマー向けではなく、社内や社外のテスト担当者さん向けのマニュアルとして作成したものです。
2020年7月現在のApp Store Connectを使って、スクショ多めで具体的な操作方法をまとめます。
1. App Store Connectにログインする https://appstoreconnect.apple.com/ にログインします。
Q. アカウントがないのでログインできません
A. 担当のかた or アプリの開発者に問い合わせてアカウントをもらってください
ログインしたら「ユーザとアクセス」をクリックして表示します。
2. Sandboxアカウント追加する 左のサイドメニューから「Sandbox テスター」を選んだあと、(+)マークの追加ボタンを押します。
姓名やメールアドレスを適切に入力します。
このときのポイントとして メールアドレスは実在するものでなくてもかまいません 1。 そのため、テスト用のアカウントはカジュアルに作成できます。 セキュリティ質問なども基本的には使いませんので適当でも大丈夫です2。
入力し終わったら[招待]ボタンを押します。
うまくいけば先程のテスター一覧に作成したSandboxアカウントが加わっているはずです。
Sandboxアカウントの作成はこれでおしまいです。
Q. 招待ボタンを押しても「エラーが発生しました。しばらくしてからもう一度お試しください。」となります。
A. メールアドレスが雑すぎるとそうなる場合があります。@マーク以降は自社のドメインにするほうが安全です。
3. Sandboxアカウントを利用するうえでの注意点 Sandboxアカウントをプロダクション環境で使ってはいけません。
以下、Appleのドキュメントからの引用です。
Sandboxテスターアカウントを使用して、テスト環境ではなく、iTunesなどのプロダクション環境に誤ってサインインした場合は、Sandboxアカウントは無効になり、以降使用できなくなります。この場合、新しいEメールアドレスを使用して新しいSandboxテスターアカウントを作成してください。
プロダクション環境で使ってしまうと、そのSandboxアカウントは使えなくなってしまう、とのこと。
Sandboxは調子が悪くなることが多々あります。
Sandbox環境は調子が悪いことがよくあります。例えば購入テストの時に「iTunes Storeに接続できません」と出て購入に失敗することがよくあります。この場合、時間をおいて試していただくと問題なくなることもあります。
時間をおいても全く購入に成功しない場合、アプリのバグの場合もありますが、現在利用しているアカウントだとうまくいかない、というケースもあります。 その場合、別のSandboxアカウントに切り替えてトライするとうまくいくこともあります。
このあたりを踏まえたうえで、心配な場合はアプリ開発者に状況を報告して相談してみてください。
4. iPhone/iPadでSandboxアカウントを利用して購入テストをする ※iOS 13のスクショを撮っています。他のOSバージョンだと若干表示などが違うかもしれません。
iPhone/iPadの「設定」を開きます。
その中の「iTunes StoreとApp Store」を選びます。
その中の一番上に「Apple ID」があり、それが現在利用している本番用のApple IDです。
このApple IDが設定されている場合はここをタップして「サインアウト」をしておくとより安全にSandboxアカウントでの購入を試せます。
※この場所では絶対にSandboxアカウントを入れないでください
この画面の一番下に「SANDBOXアカウント」という項目があります。ここで「サインイン」を押し、作成したSandboxアカウントでログインしてください。
5. アプリで購入テストをする ログインに成功したらテスト対象のアプリでの購入テストをお試しください。</description>
    </item>
    
    <item>
      <title>Human Interface GuidelinesのApp Clipsの章の日本語訳</title>
      <link>https://www.tokoro.me/posts/hig-app-clips/</link>
      <pubDate>Tue, 07 Jul 2020 15:27:31 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/hig-app-clips/</guid>
      <description>前回、HIGのWidgetsの章を日本語訳した記事が好評だったので、今回はWidgesと同じくiOS 14の目玉機能の「App Clips」についても日本語訳しました。 Human Interface Guidelines (HIG) の App Clips がソースです。
2020年7月8日時点のものを訳します。
前回同様、訳しながらドキュメントの意図が正確に分からなかった部分や主観で大きく意訳した箇所は注釈に明記します。
App Clips App Clipはアプリの軽量版で、ユーザーにアプリをダウンロード・インストールさせずに、日常のタスクを素早く実行させることができます。 ユーザーは様々な状況や目的でApp Clipを見つけ、利用できます。 物理的な場所では、NFCタグや視覚的なコードをスキャンしてApp Clipを起動します。 デバイス上では、位置情報に基づくSiriからの提案、地図アプリ、ウェブサイトのSmart App Banners、メッセージアプリで友達が共有してくれたリンクをタップする、などからApp Clipsを起動します。
あなたのアプリが、限られた時間の中でタスクを実行するのに役立つ体験（in-the-moment experience）を提供しているなら、App Clipを導入することを考えてみましょう。 例えば、
レンタル自転車にNFCタグを付け、それをスキャンしてApp Clipを起動し、その自転車をレンタルしてもらうことができます。 コーヒーショップでは、ウェブサイトにSmart App Bannerを設置して、そこからすぐに注文できる事前注文用のApp Clipを提供することができます。ユーザーはメッセージアプリでそのウェブサイトへのリンクを友達1に共有し、共有された友達もそのリンクをタップするだけでApp Clipから注文できます。 レストランでは、ユーザーが地図アプリやSiriからの提案からApp Clipを起動できるようにしたり、テーブルでNFCタグをスキャンしてもらいApp Clipで食事の支払いをするようにできます。 美術館では、来館者に展示品の名札の横にあるQRコード2をスキャンしてもらい、App ClipでARコンテンツを表示したり、音声解説を提供したりできます。 App Clipは、アプリをインストールしていないユーザーにアプリの機能の一部をシェアできる強力な方法です。 開発者向けのガイドは App Clips を参照してください。
優れたApp Clipのデザイン 本質的な機能にフォーカスしましょう。 App Clipのインタラクションは素早く、集中して行われるべきです。 目の前のタスクを達成するために必要な機能に限定してください。 高度な機能や複雑な機能はアプリのために取っておきましょう。
App Clipをマーケティング目的だけに使用してはいけません。 App Clipは真の価値を提供し、人々がタスクを達成するのに役立つものでなければなりません。 サービスや製品を宣伝するための手段として使用しないでください。
直線的で使いやすく、焦点を絞ったユーザーインターフェースをデザインしましょう。 App Clipには、タブバーや複雑なナビゲーション、設定があってはいけません。 画面の数や入力フォームの数も最小限に抑えましょう。 余分な情報を削り、できる限りシンプルなユーザーインターフェースにしてください。
起動時には、最適な画面を表示しましょう。 不要なステップをスキップして、ユーザーの現在の状況に最も適した画面をすぐに表示するようにしてください。
ユーザーがすぐに利用できるようにしましょう。 App Clipには本当に必要なアセットのみ含めてください。 スプラッシュ画面を入れるなどしてユーザーに起動を待たせるようなことをしてはいけません。</description>
    </item>
    
    <item>
      <title>Human Interface GuidelinesのWidgetsの章の日本語訳</title>
      <link>https://www.tokoro.me/posts/hig-widgets/</link>
      <pubDate>Thu, 02 Jul 2020 17:32:57 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/hig-widgets/</guid>
      <description>WWDC20でiOS 14の新機能として発表されたWidgetsについて勉強するため、Human Interface Guidelines (HIG) の Widgetsの章 を日本語訳します。
日本語で理解しやすいよう、ぼくの感性で意訳しちゃう部分もありますのでご了承ください。 訳しながらドキュメントの意図が正確に分からなかった部分は注釈に明記します。
2020年7月3日時点のものを訳します。
Widgets Widgetにより、アプリの重要なコンテンツをiPhone、iPad、Mac上の一目で分かる場所に表示できます。 Widgetは便利で楽しく、iPhoneのホーム画面をユーザーごとにパーソナライズするのにも役立ちます。
Widgetは、iOS 14以降と macOS 11以降で利用できます。 Widget Extensionを作成する という開発者向けのガイド記事があります。
Widgetsの詳細 Widgetには小、中、大の３つのサイズがあります。 iPhone、iPad、Macのどのプラットフォームでも、ユーザーはWidgetギャラリーからWidgetを見つけ、お好みのサイズを選べます。 また、ユーザーは後からWidgetを好きな場所に移動させたり、WidgetごとにWidgetが用意したパラメータを設定することができます。 例えば、ホーム画面に小さなお天気Widgetをいくつか設置して、それぞれのWidgetに別々の場所の天気を表示する、など。 Widgetは、iPhoneならホーム画面やTodayビュー、iPadならTodayビュー、macOSなら通知センターに設置できます。
iPhoneとiPadではWidgetギャラリーの中にスマートスタックがあります。 スマートスタックにはユーザーがよく使うアプリのWidgetがデフォルトで含まれています（後から変更もできます）。 スマートスタックはiPhoneのホーム画面と、iPhone/iPadのTodayビューに設置できます。 スマートスタックは時間とともにだんだんと賢くなり、Siriが自動で現在の状況に適したWidgetを一番上に表示してくれます。 また、ユーザーが自分で作ったWidgetのスタックでも、スタックの設定からスマート回転（Smart Rotate）をOnにすれば、Siriによる最適なWidgetの自動表示が有効になります。
NOTE
iOS 13以前のiOS用に作られた古いWidgetはホーム画面では利用できませんが、Todayビューの下部やmacOSの通知センターでは引き続き利用できます。
使いやすく焦点を絞ったWidgetの作成 Widgetをタップすることでアプリ本体を開きアプリ内でより多くのことをできますが、Widgetの主な目的はユーザーがアプリ本体を開かなくてもタイムリーにユーザーごとにパーソナライズされた少量の情報を表示することです。 Widgetで実現すべき1つのアイデアを特定し、表示する情報の焦点を絞ることが、Widgtetのデザインプロセスにおける重要な最初のステップです。
Widgetで実現するアイデアは1つに集中させてください。 ほとんどの場合はアプリのメインアイデアをWidgetに適用できるでしょう。 例えば、天気アプリでは特定の場所の天気を表示し、カロリートラッキングアプリではその日の消費カロリーを表示し、ニュースアプリではトレンドを表示するなどが考えられます。 また、ゲームアプリでキャラクターのステータスを表示したり、お絵かきアプリでお気に入りのスケッチを表示したりと、アプリのメインアイデアの1つの部分に焦点を当てるのも効果的です。
どのサイズのWidgetでも、Widgetのアイデアに直接関係する情報のみを表示してください。 大きなWidgetでは、より多くのデータを表示したり、より詳細な情報を表示することができますが、Widgetのアイデアに集中することが重要です。
例えば天気アプリの場合、小サイズのWidgetには現在の気温と天気、その日の最高気温と最低気温を表示します。
中サイズのWidgetには小サイズと同じ情報に加えて6時間分の時間ごとの予報も表示します。
大サイズのWidgetには6時間分の予報に加え、5日後までの予報も表示します。
アプリ本体を起動するだけのWidgetは避けましょう。 ユーザーがWidgetを評価するのは、意味のあるコンテンツにすぐにアクセスできるからであって、アプリを開くためのショートカットになるからではありません。
Widgetを複数のサイズで提供することで付加価値が得られる場合は、複数のサイズを提供しましょう。 小さいWidgetのコンテンツを拡大してエリアを埋めただけの大きなWidgetを作るのは避けましょう。すべてのサイズのWidgetを提供することよりも、あなたのアイデアを完璧に表現できる１つのサイズのWidgetを作成することのほうが重要です。
1日を通してダイナミックに変化することが期待されます。 Widgetの表示に変化がなければ、ユーザーはWidgetを目立つ位置に置き続けようとは思わないでしょう。 Widgetは分刻みで更新されるわけではありませんが、頻繁に見てもらうWidgetにするためにはコンテンツの鮮度を保つことが重要です。
驚きと喜びを与えてください。 例えばカレンダーWidgetなら、誕生日や祝日に特別な表示をすることができそうです。
Widgetの設定とインタラクティブ性 Widgetに設定すべき項目がある場合は設定可能なWidgetにしましょう。 多くの場合、Widgetに有用なコンテンツを表示するためには、ユーザーが見たい情報をあらかじめ指定する必要があります。 例えば、天気Widgetでは場所を選択したり、株価Widgetでは表示する株価を選択したりする必要があります。 一方で、ポッドキャストWidgetなら、最近のコンテンツを表示するようにあらかじめ設定されているので、カスタマイズする必要はありません。 設定可能なWidgetを作成する場合は、あまり多くの設定を要求したり、複雑な情報を要求したりすることは避けてください。 Widgetの設定画面はOSが自動的に生成してくれるので設定画面を自分で作る必要はありません。 開発者向けに 設定可能なWidgetを作成する というガイド記事もあります。
Widgetをタップしたときに、アプリの適切な画面を開くようにしましょう。 ユーザーがWidgetをタップすると、Widgetはアプリ本体にDeep Linkし、Widgetのコンテンツに直接関連する詳細情報やアクションを提供することができます。 例えば、ユーザーが特定の株価を表示しているWidgetをタップすると、株価アプリのその株価の詳細な情報を表示する画面を開きます。 また、ウォッチリストの一部を表示しているWidgetをタップすると、アプリが開いて全てのウォッチリストを確認できます。</description>
    </item>
    
    <item>
      <title>Swift AWS Lambda Runtimeで犬の写真を毎朝Slackに送ってみる</title>
      <link>https://www.tokoro.me/posts/swift-aws-lambda-runtime2/</link>
      <pubDate>Mon, 15 Jun 2020 14:25:23 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/swift-aws-lambda-runtime2/</guid>
      <description>導入 前回の Swift AWS Lambda Runtimeのサンプルをデプロイしてみた の続きです。
特に犬の写真を毎朝送ってほしいというわけではないですが、Swift AWS Lambda Runtimeを試すにあたっての題材として、
AWS Lambdaのスケジュール式トリガーで毎朝自動で実行する 画像検索APIで犬の写真をランダムに取ってくる それをSlackに送る というのをやってみます。
画像検索API 画像検索APIは手っ取り早く使えそうなAzureの Image Search API を使ってみます。 Azureのアカウントさえ作れば、月1000回までは無料で叩けるようです。
curlで叩くとすると、
curl &#39;https://api.cognitive.microsoft.com/bing/v7.0/images/search?q=dog&#39; \ -H &#39;Ocp-Apim-Subscription-Key: YOUR_KEY&#39; となります。
リクエストパラメータに q=検索ワード リクエストヘッダーに Ocp-Apim-Subscription-Key: YOUR_KEY を渡します1。
Slackへの通知 Slackの Incoming Webhook用のURLを取得します。
URLを取得したら、curlで叩くとすると、
curl -X POST -H &#39;Content-type: application/json&#39; \ --data &#39;{&amp;quot;text&amp;quot;:&amp;quot;犬の画像のURL&amp;quot;}&#39; \ https://hooks.slack.com/services/your/incoming/webhook とするだけです。
POSTデータで{&amp;quot;text&amp;quot;:&amp;quot;犬の画像のURL&amp;quot;} を送ってあげるだけですね。
Lambda関数を作る これで画像検索APIとSlackへの通知部分は準備できたので、あとはメインディッシュのLambda関数を作るだけです。
Packageの作成 まずは、
swift package init --type executable --name DogImage とPackageを作り、 GitHub上のサンプル をベースにPackage.</description>
    </item>
    
    <item>
      <title>Swift AWS Lambda Runtimeのサンプルをデプロイしてみた</title>
      <link>https://www.tokoro.me/posts/swift-aws-lambda-runtime/</link>
      <pubDate>Thu, 11 Jun 2020 14:57:28 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/swift-aws-lambda-runtime/</guid>
      <description>導入 先日（2020/5/29）、Swift AWS Lambda Runtimeが発表されましたね！
https://swift.org/blog/aws-lambda-runtime/
以前から Custom AWS Lambda runtimes を使い、自分でも実現することができましたが、このオフィシャルなライブラリを使い、よりシンプルに安全にSwift製AWS Lambda関数を構築できるようになります。
swift.orgの説明には、
The library is an implementation of the AWS Lambda Runtime API and uses an embedded asynchronous HTTP Client that is fine-tuned for performance in the AWS Runtime context. The library provides a multi-tier API that allows building a range of Lambda functions: From quick and simple closures to complex, performance-sensitive event handlers.
AWS Lambda runtime用にパフォーマンスを調整した非同期HTTPクライアントが組み込まれている さまざまな種類のLambda関数を作るのに便利なAPIを提供している とあります。</description>
    </item>
    
    <item>
      <title>Github ActionsからSlackへ通知するのを良い感じにしたい</title>
      <link>https://www.tokoro.me/posts/github-actions-context/</link>
      <pubDate>Wed, 13 May 2020 17:26:38 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/github-actions-context/</guid>
      <description>この記事はpushをトリガーとしたGitHub Actionsのワークフローを前提として書いています。
概要 GitHub Actions、簡単便利で良いですね！
ぼくも遅まきながら使いはじめ、先日、Git pushをトリガーにデプロイしてSlackで通知、とよくあるワークフローを追加して運用しはじめました。
Slackへの通知も Marketplace に数ある既存Actionを選んで利用すれば、すぐに実現できました。すごい！
ぼくはこんな感じにしたかった とはいえ、贅沢を言えば、ぼくは
レガシーなCustom integrationsのIncoming Webhooksでなく、きちんと新しいIncoming Webhooksでやりたい ref: https://api.slack.com/legacy/custom-integrations#incoming-webhooks Action独自のパラメータでなくSlackが定義しているMessage payloadsのフィールドをそのまま指定したい ref: https://api.slack.com/reference/messaging/payload GitHubで変更差分を見るためのURLを追加したりとか、お好みでカスタムしたい と思い、意外とそれが叶う既存Actionが見つからなかったため、GitHub Actionsを作る練習も兼ねて、自作することにしました。
作ったActionは https://github.com/marketplace/actions/slack-incoming-webhook です。
実際の通知 テキストメッセージ送るだけ テキストメッセージを送るだけなら、どのActionを使っても同じようなものですが、こんな感じに
Incoming WebhookのURLをenvに指定 textフィールドを指定 フィールド名を SlackのPayloadの仕様 に合わせてます の２つだけ設定すると、
- name: Slack Notification uses: tokorom/action-slack-incoming-webhook@main env: INCOMING_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }} with: text: Hello, Slack! こんな感じにSlackにメッセージを送れます。
いろいろカスタム 次に、textだけでなく、attachmentsフィールドも指定して、
成功ならgreenなど色をつける pushした人の名前やアイコンも表示する GitHub Actionsの該当のワークフローへのリンクをつける 変更差分を見るためのCompareページへのリンクをつける といろいろカスタムしてみます。
- name: Set COMMIT_MESSAGE run: echo ::set-env name=COMMIT_MESSAGE::$(echo &amp;quot;${{ github.</description>
    </item>
    
    <item>
      <title>Vimにスクショを直接Markdownで貼り付ける</title>
      <link>https://www.tokoro.me/posts/vim-markdown-paste-from-clipboard/</link>
      <pubDate>Thu, 30 Apr 2020 18:01:01 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/vim-markdown-paste-from-clipboard/</guid>
      <description>Photo by Jae Park on Unsplash
前回 前回の記事では、画像ファイルをVimにドラッグ＆ドロップして、それをコマンド一発で、
ImageOptimで画像を最適化 記事ごとの画像ディレクトリを自動作成してそこに画像をコピー Vimに ![image](/images/記事名/画像名) とMarkdown方式で埋め込む という便利環境を作りました。
そのときの課題として「どうせなら既存画像だけじゃなくてスクショもコマンド一発でVimにMarkdown形式で貼り付けたいなあ」というのがありました。
今回はそこを解決します！
pbpasteはダメだった なんとなくpbpasteコマンドでゴニョゴニョするんだろうな思っていたのですが、pbpasteはテキストしか扱えないということがわかりました&amp;hellip;
screencaptureコマンドを使う しかしMacにはscreencaptureというコマンドがあり、
screencapture -i 出力ファイル名 とすると、shift + command + 4 で起動するインタラクティブなスクショモードを開始し、撮影後のスクショを指定したファイル名で保存してくれる、ということがわかりました。
vim pluginを拡張 前回、特定のコマンドを実行して、Vimの現在行を置き換えるpluginを作って使ったのですが、今回から、
現在行の画像ファイル名を使って画像を適切に埋め込むコマンド スクショを撮影して現在行に埋め込むコマンド の２つを使い分ける必要が出てきました。
そのため、前回のpluginを少し拡張して、
command! -nargs=0 MarkdownImageFromLine :call vim_replace_current_line#execute(&amp;quot;./.vim-replace-current-line/markdown-image-from-line&amp;quot;) command! -nargs=0 MarkdownImageWithScreenshot :call vim_replace_current_line#execute(&amp;quot;./.vim-replace-current-line/markdown-image-with-screenshot&amp;quot;) とvimrcで好きなコマンド名でそれぞれ別のコマンドを叩けるようにしました。
今回のものは:MarkdownImageWithScreenshotというコマンドをVim上で叩くと、markdown-image-with-screenshotというシェルコマンドを実行し、そのレスポンスを現在行に埋め込む、という形です。
仕組み自体は前回と変わりません。
このpluginは GitHub に置いてあります。
スクショを撮影して&amp;hellip;のコマンド markdown-image-with-screenshotコマンドの具体的な中身は、
#! /bin/sh IMAGEDIR=&amp;quot;content/images/$2&amp;quot; CURRENTTIME=`date +%s` IMAGEFILENAME=&amp;quot;ss-${CURRENTTIME}.png&amp;quot; TARGET=&amp;quot;${IMAGEDIR}/${IMAGEFILENAME}&amp;quot; IMAGETAG=&amp;quot;![image](/images/$2/${IMAGEFILENAME})&amp;quot; mkdir -p ${IMAGEDIR} screencapture -i &amp;quot;${TARGET}&amp;quot; echo &amp;quot;${IMAGETAG}&amp;quot; IMAGEOPTIM=&amp;quot;open -a ImageOptim&amp;quot; `${IMAGEOPTIM} ${TARGET}` です。</description>
    </item>
    
    <item>
      <title>VimでMarkdown形式でブログ記事を書くときに簡単に画像を埋め込む方法</title>
      <link>https://www.tokoro.me/posts/vim-markdown-image-tool/</link>
      <pubDate>Tue, 31 Mar 2020 16:38:32 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/vim-markdown-image-tool/</guid>
      <description>Photo by Victor Grabarczyk on Unsplash
ブログ記事書くとき画像を埋め込むのが面倒 こういったブログ記事は、皆さんどういう執筆環境で書いているでしょうか？
最近だとHugoなどの静的サイトジェネレータを利用することも多いのではないでしょうか。 この記事もHugoで運用しています。
記事を投稿するときは、いつもVimでさらっとMarkdown形式で書き上げ、ぱぱっとデプロイコマンドを打つだけで簡単便利な環境なのですが、唯一、記事に画像を埋め込むのだけが面倒だと感じてます。
特に、いわゆるブログサービスを利用している場合には、記事作成ページに埋め込みたい画像をドラッグ＆ドロップするだけで画像をアップロード＆埋め込みできてしまうので、それとの比較で面倒さが際立ちます。
手動での画像埋め込み手順 これまで手動で画像を埋め込む際には、このブログ記事の場合だと、
各記事用の画像ディレクトリとして content/images/記事名 ディレクトリを作成 埋め込みたい画像を content/images/記事名 以下にコピー 記事内に ![image](/images/記事名/画像名) を埋め込む 必要に応じてImageOptimなどで画像の最適化 をしていました。
決して難しいことはありませんが地味に面倒でした。
ドラッグ＆ドロップでなんとかならない？ 結論として、私の執筆環境である「Terminal + Vim」ではドラッグ＆ドロップをうまくハンドリングする方法がわからず、ドラッグ＆ドロップだけでなんとかはなっていません。
ただ、TerminalのVim上に画像ファイルをドラッグ＆ドロップすると、その画像ファイルの絶対パスがVimに埋め込まれますので、その行でワンコマンドかますだけでなんとかなりそうだなと思い、Vim用のpluginを作りました。
具体的には、デスクトップ上のdog.jpgをドラッグ＆ドロップすると、Vim上に
/Users/tokorom/Desktop/dog.jpg が埋め込まれますので、この行でコマンドを打ち、あとは必要なことを自動でやってくれる、という方式です。
現在行のファイルパスに対してなにかをするplugin このファイルパスに対してなにをしたいかは執筆環境により異なりますので、pluginに追加したのは、
function vim_replace_current_line#execute() let line = getline(&#39;.&#39;) let result = system(g:vim_replace_current_line#command . &#39; &#39; . expand(&#39;%&#39;) . &#39; &#39; . expand(&#39;%:t:r&#39;) . &#39; &#39; . trim(line)) call setline(&#39;.&#39;, trim(result)) endfunction という３行のシンプルなfunction１つだけです。
ここでやっているのは、
特定のコマンドを実行し その引数として「編集中のファイル名」「ファイル名の拡張子を抜いた部分（記事名を想定）」「現在行（画像ファイルのパスを想定）」の３つを渡す コマンドの実行結果で現在行を置き換え ということだけです。</description>
    </item>
    
    <item>
      <title>５分で終わるFirebase App Distribution（プロジェクト作成からテスターへの配信まで）</title>
      <link>https://www.tokoro.me/posts/firebsae-app-distribution/</link>
      <pubDate>Mon, 10 Feb 2020 10:43:31 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/firebsae-app-distribution/</guid>
      <description>Firebase App Distiribution 先日BETA公開されたFirebase App Distributionですが2020年3月終了のFabricからの移行先としてはもっとも有力ですよね1。
先日「Firebaseを利用していない既存アプリを配信するためだけにFirebase App Distributionを使いたい！」と思い試してみたら、あまりにも簡単で「これは10分で設定から配信まで完了するんじゃない？」と思い、実際に、
Firebase未導入のビルド可能なプロジェクトがある状態 Firebaseのプロジェクトを作成するところから開始 配信用にアプリをビルドしてFirebase App Distributionでテスターに配信するところを終了 という条件で実際にストップウォッチで測ってやってみたところ、なんと「4分43秒」で終わりました！
この記事用にスクショを撮影しながらでもこのタイムだったので、本気でタイムアタックしたら3分切れると思います。
ということで「10分で終わるFirebase App Distribution」という記事を書く予定だったのを「5分で終わるFirebase App Distribution」に変更してお届けします。
そもそも アプリにFirebaseを導入するには基本的にはfirebase-ios-sdkをアプリに組み込む必要があります。
しかし、App Distributionだけを利用したい場合にはこのSDKの組み込みは不要です。この記事ではSDK組み込みをスキップしていますので、AnalyticsなどFirebaseの他機能を利用したい場合には他のチュートリアルをご利用ください。
設定チュートリアル（実際の手順） Firebaseのプロジェクトを作成 まずはFirebaseのConsoleにをブラウザで開いてプロジェクトを作成します 今回はApp Distributionのみ利用するので「Googleアナリティクス」はOffにしておきます プロジェクトを作成したらここにiOSアプリ（配信しようとしているもの）を追加します 設定が必要なのはバンドルIDだけです XcodeのプロジェクトからBundle Identifierをコピーしてペーストします 今回は「設定ファイルのダウンロード」「Firebase SDKの追加」「初期化コードの追加」はスキップしてしまいます そのまま「コンソールに進む」としてしまってOK これでFirebaseのプロジェクトが作成され、配信するアプリを登録できました。
実際に配信する それでは、実際にアプリをApp Distributionで配信してみましょう
まず、アプリをArchiveして適当な場所にエクスポートします エクスポートしたアプリのipaをApp Distributionのページにドラッグ＆ドロップします アップロードが終わったらテスターのメールアドレスを追加します これでテスターに配信完了です！
おわり これだけで終わりです。
あとはテスターにこんなメールが届いているはずですので、
「Get setup」からインストールしてもらうだけです。
この記事で書いていないこと AdHoc or Enterprise? AdHoc配信の場合のUDID管理まわり fastlaneなどの設定 Fabricからのオフィシャルな移行先なので&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description>
    </item>
    
    <item>
      <title>SwiftUIアプリを24時間で作ってリリースするひとりハッカソンの結果報告</title>
      <link>https://www.tokoro.me/posts/swiftui-hackathon/</link>
      <pubDate>Mon, 27 Jan 2020 14:32:55 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/swiftui-hackathon/</guid>
      <description>2019年はSwiftUI誕生の年 2019年のSwiftUIの発表はたいへんインパクトがありましたね！ Objective-CからSwiftへの変遷と同様に、ここ数年で間違いなくSwiftUIがiOSアプリ開発のスタンダードになるものと思います。
いっぽうでSwiftUIはまだまだ機能不足、情報不足で実際にリリースする案件に適用するには心許ないというのが2020年1月時点での現状です。特に自社のメインサービスやクライアントワークでSwiftUIの導入を決断をするのはなかなか難しい時期かもしれません。
また次の6月のWWDCでアップデートが発表され状況は変わってくると思いますが、それを待つのも&amp;hellip;
ということでハッカソン ということで、冬休みにひとりでハッカソンを実施して、
24時間でSwiftUIでiOSアプリを開発して AppStoreでリリースする ところまでやる！ということにしました。
自分で勝手に企画して出すアプリですのでSwiftUIを使っても誰にも文句は言われません！
必須利用技術 このハッカソン企画での必須利用技術は、
SwiftUI Firebase（Firestore） Sign in with Apple の３つとしました。
SwiftUI はもちろんですが、ローカルオンリーで動作するアプリだとSwiftUIの検証には弱いかなと思い、サーバにデータを保管するようにしバックエンドには Firebase(Firestore) を利用することにしました。 また、SwiftUIを採用する時点でターゲットOSがiOS 13以降になるので、ついでにiOS 13の新要素 Sign in with Apple でのSign inを実装することにしました。
リリースの定義 今回はゴールであるリリースの定義を、
アプリを開発し終えて AppStore用のメタデータやスクリーンショットを作って投稿して 実際に審査に出す ところまで、としました。
作るアプリ 作るアプリはちょうど自分が欲しいと思っていた「こどもたちのお金を親が管理するアプリ」にしました。
Photo by Michael Longmire on Unsplash
解決したい課題 我が家ではこどもたちにお金の教育を兼ねて毎月おこづかいを渡しているのですが、
先月のおこづかい渡したっけ？渡してなかったけ？とよくわからなくなる お年玉が高額で幼稚園児に管理させるのが不安（かといって子供の銀行口座を作るのは面倒） 弟が姉の貯金箱を漁る事件が発生！ お店でこどもが「おこづかいでこのおもちゃ買いたい！」という時におこづかいを持ってきていない ○○カメラでおこづかいでおもちゃを買わせたいが、ほんとは〇〇カメラのポイント使っちゃいたい！ ほんとは余っている〇〇Payで支払いたい！ など様々な悩みが出てきました。
解決するための機能 これらを解決するためには、
こどもに現金を持たせないで親が残高だけ管理すれば十分 記録さえ残せば、親の財布が銀行代わりで、財布から出金、財布に入金でかまわない 入金、出金の記録は親もあとから削除・修正できないようにして証拠として残せばこどもも安心 普段使いの少額の現金はその残高から出金してこどもに渡せばOK おこづかいを使う時は親の財布から出金すればよいので〇〇カメラのポイントも○○Payもクレジットカードも使い放題！ と考え、シンプルに親のアプリでこどものおこづかい残高を管理するのがよいと仮定しました。
24時間で実装する機能 こういったアプリを作るうえで欲しい機能はいろいろと浮かんだものの、慣れないSwiftUIを使って24時間となるとだいぶ機能を絞る必要があると思い、
こどもは複数人管理できる おこづかいやお年玉などを手動入金できる こどもが使った額を出金できる Sign in with AppleでSign inできる Firebase上に残高と履歴を保存できる を必須機能としました。</description>
    </item>
    
    <item>
      <title>HomeKit ADKでSlackにメッセージ送信するアクセサリを作ってみる</title>
      <link>https://www.tokoro.me/posts/homekitadk/</link>
      <pubDate>Mon, 23 Dec 2019 11:47:15 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/homekitadk/</guid>
      <description>HomeKitADKのオープンソース化 つい先日（2019/12/18）、AppleがAmazon、Google、Zigbee Allianceと、スマートホームデバイスに関するワーキンググループを結成したとのビッグニュースが発表されましたね！
https://www.apple.com/jp/newsroom/2019/12/amazon-apple-google-and-the-zigbee-alliance-to-develop-connectivity-standard/
これに伴い、HomeKitに対応したアクセサリを開発するためのHomeKit ADKがオープンソース化されました。
https://github.com/apple/HomeKitADK
HomeKit対応アクセサリ作ってみよう！？ ちなみにHomeKitの世界ではHomeKitに対応した機器のことをアクセサリと呼びます。
ということで早速HomeKit対応アクセサリを作ってみましょう！ といってもハードウェアを作るわけではなく、手元のMac上で動き、HomeアプリからOnするとSlackになにか投稿するというアクセサリを作る実験をしてみようと思います。
と考えたわけですが、12/23現在ですとまだドキュメント等も優しくはないので、リポジトリを覗いてもなにがなんやらの状態です。
ひとまず、READMEに書かれているとおりに、必要なものをbrew installして、make allすれば、なにやらビルドは成功します。そして、ビルドされた
Output/Darwin-x86_64-apple-darwin19.0.0/Debug/IP/Applications/Lightbulb.OpenSSL を実行したらなにやら動きます1。
こちらですが、
まず、HomeKit対応したアクセサリはHomeKit Accessory Protocol（HAP）により操作される HomeKit対応するアクセサリではHAP Accessory Serverが動いている必要があり、これによりHomeアプリへの追加だったり、「ライトを点灯して」といった命令を受け入れる 上で動かしているLightbulb.OpenSSLは、ライト用のHAP Accessoryのサンプル という理解で良さそうです。
LightbulbのサンプルをiPhoneのHomeアプリに追加してみよう 上のLightbulb.OpenSSLを動かしている状態で、iPhoneのHomeアプリを起動し、以下のようにすると、このサンプルのアクセサリを実際に追加できます。
アクセサリの追加から「コードがないか、スキャンできません」を選ぶ 近くのアクセサリに「Acme Light Bulb」というのが表示されるので追加する 設定コードの入力を求められるので11122333を入力する なお、設定コードは https://github.com/tokorom/HomeKitADK/blob/lightbulb_slack/PAL/Mock/HAPPlatformAccessorySetup.c#L12 に書かれていたものを使ってみました。将来、このサンプル用の設定コードは変わるかもしれません。
これでサンプルのLightbulbがHomeアプリに追加されましたので、Homeアプリ上でこのサンプルのライトを点灯/消灯することができるようになりました。
といっても実際に電球があるわけではないので、点灯したよ、消灯したよ、というのはログ上で確認できるのみです。ライトの点灯/消灯を切り替えると、
Info HandleLightBulbOnWrite: true Info HandleLightBulbOnWrite: false といったログが確認できるかと思います。
サンプルを改造してSlackにメッセージを送信させよう HomeKit対応したライトを作る場合は、上のHandleLightBulbOnWriteのところで実際にライトを点灯させるコードを書くことになりそうです（Raspberry Piなどでそれをやってみるのも簡単と思います）。
今回はSlackにメッセージを送信するアクセサリを作るというのが目的なので、
https://github.com/tokorom/HomeKitADK/blob/lightbulb_slack/Applications/Lightbulb/App.c#L165-L184
このあたりに、SlackにメッセージをPOSTする機能を追加しましょう。
ただ、今回は実験なので（正直、C言語で書いてビルドし直して&amp;hellip;というのが面倒なので）、
#include &amp;lt;stdlib.h&amp;gt; して、
if (value) { system(&amp;quot;./handleLightBulbOn&amp;quot;); } ライトがOnになったら外部のShellスクリプトを叩くという実装だけして、あとはShellスクリプトで書く&amp;hellip;という形に逃げちゃいます。。。
Slackにメッセージ送信するスクリプトの追加 ここからは慣れ親しんだSwiftなどでSlackにメッセージ送信するコード書くだけなので、ここで紹介するまでもないです。
例えば、こんなかんじのものです。
この例ではSlackのIncoming Webhooksを使っています。
touch handleLightBulbOn chmod +x handleLightBulbOn vim handleLightBulbOn #!</description>
    </item>
    
    <item>
      <title>NFCタグ で鍵を開けよう（6） iOS13時代の最終形</title>
      <link>https://www.tokoro.me/posts/nfc-iphone-6/</link>
      <pubDate>Wed, 30 Oct 2019 13:57:46 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/nfc-iphone-6/</guid>
      <description>この記事は「NFCタグ で鍵を開けよう」シリーズの第6弾です。 これで最後の予定です。
NFCタグにURIを書き込む iPhoneを鍵とし、ドアにNFCタグを設置するパターン iOSアプリを経由してセキュリティレベルをあげる NFCタグを鍵とし、ドアにNFCリーダーを設置するパターン（まだ書いてないけど気が向いたら書くかも） より実用的にしていくために iOS13時代の最終形（この記事） 3〜5についてはiOS13の機能を使った最終形で、もうこれでいいじゃん！となったのでスキップします。（NFCタグを鍵にするパターンはまだ必要なケースあるかも）
なにができる？ iOS 13でNFCタグをトリガーとしてアプリを叩けるようになった iOS 13（正確にはiOS 13.1）で、純正アプリの ショートカット にオートメーションという機能が追加されました。 このオートメーションのトリガーの１つに、なんと NFCタグ があるのです。
そして、それをトリガーとしてサードパーティ製アプリの Siri Shortcut を呼び出せます。 つまり、アプリがSiri Shortcutに対応していれば、そのアプリをNFCタグタッチだけで動作させられるようになったということです。 そして、我らがSesameもこれに対応しています。
１行でまとめると、
iOS 13なら何も開発しないで、NFCタグタッチでSesameの解錠ができる ということです。
対応デバイス 正確には、iOS 13であっても Background Tag Reading に対応したiPhoneでないとこの機能は使えません。2019年10月時点での対応機種は、
iPhone XR iPhone XS iPhone XS Max iPhone 11 iPhone 11 Pro iPhone 11 Pro Max の６機種です。
実際にやってみよう NFCタグの準備 NFCタグには何も情報を書き込む必要はありません。
など適当なNFCタグを買ってきたままそのまま使えます。
オートメーションの作成 次に、ショートカットアプリでオートメーションを設定します。
解錠をマイショートカットとして追加 Sesameを普段から使っていれば、ギャラリータブの中に 「xxx」を解錠 というSesame用のショートカットが含まれているはずです。それに適当な音声コマンドをあてて Siriに追加 をしておきます。Siriに追加されたショートカットをオートメーションのアクションとして指定できるようになります。
オートメーションを追加 それでは、実際にNFCタグタッチによるオートメーションを追加してみましょう。</description>
    </item>
    
    <item>
      <title>iOSDC Japan 2019 に「Advanced Segue」というセッションで登壇します</title>
      <link>https://www.tokoro.me/posts/iosdc_2019_pre/</link>
      <pubDate>Wed, 04 Sep 2019 18:09:20 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/iosdc_2019_pre/</guid>
      <description>明日、2019年9月5日（木）から開催される iOSDC Japan 2019 に「Advanced Segue」というセッションで登壇予定です。
スケジュール 2019/09/05（木） 18:40〜 Track B レギュラートーク（30分） Proposal 概要 Proposalからの抜粋です。
Segueでできること、できないこと、とにかくSegue（UIStoryboardSegue）について凝縮して紹介します。 通常の使い方からUnwindSegueを使うメリット、Xcode 11から利用できるようになったIBSegueActionまで。 Segueを愛して7年の私が、これまでSegueを避けてきた皆さんにもSegueの魅力を知っていただけるようなトークができればと考えています。
見ていただきたいかた 同じくSegueを愛する同士 Segueを使ってはいるがもう少しどうにかならないかと思っているかた 敢えてSegueを使っていないかた Segueを愛するかたはもちろんですが、敢えてSegueを使っていないかたにこそ価値のあるセッションになるかもしれません。 なお、このセッションを聞いて絶対Segueを使ってくれ！とは考えていないです。 普段Segueを使っていないかたにとっては、３０分でSegueについてキャッチアップしていただき「SegueのProsはもちろん知ってるけど、やはり敢えて使ってないんだよ」と自信を持って言える状態になっていただければ幸いです。
具体的な内容 Basic Segue iOS 13 New Features! Advanced Tips というAgendaの予定です。
Basic Segue SegueはViewControllerを開くためだけにあるのではないですよ Segueには大きく４種がありますよ という基本部分と、
Segueを使うPros Segueを使うCons について簡単に復習をさせていただきます。
prepareForSegue についてもここに含みます。
iOS 13 New Features! Segue ActionによりSegueのConsの解決 を中心にお話します。
Advanced Tips Unwind Segueの活用例 Custom Segueの活用例 についてTips形式で実例を紹介していきます。 中にはDestination ViewControllerを使わないTipsも！？
「え！Segueでこんなこともできるの？」「おお、このTipsいいじゃん！使おう」と少しでも新しい発見が含まれていると嬉しいです。
見どころ iOS 13のSegue Actionについて未知のかたはこのセッションでなくとも必ずキャッチアップいただきたい！ Segueをご活用のかたにとっても、Custom Segueの活用Tipsには面白い内容が含まれていると思います これを機に「俺はこんなCustom Segue使ってるぜ！」というのをぜひ語り合いましょう！ </description>
    </item>
    
    <item>
      <title>NFCタグ で鍵を開けよう（2） iPhoneを鍵とし、ドアにNFCタグを設置するパターン</title>
      <link>https://www.tokoro.me/posts/nfc-iphone-2/</link>
      <pubDate>Mon, 01 Apr 2019 15:11:25 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/nfc-iphone-2/</guid>
      <description>この記事は「NFCタグ で鍵を開けよう」シリーズの第2弾です。 このシリーズは以下５つの記事に分けられて投稿予定です。
NFCタグにURIを書き込む iPhoneを鍵とし、ドアにNFCタグを設置するパターン（この記事） iOSアプリを経由してセキュリティレベルをあげる NFCタグを鍵とし、ドアにNFCリーダーを設置するパターン（まだ書いてないけど気が向いたら書くかも） より実用的にしていくために iOS13時代の最終形 この記事でやること 前回は、NFCタグにhttps://tag.exsample.com/lockというURIを書き込むことに成功し、それをiPhone XR/XSで読み込めることを確認しました。
今回は、このURIで動作するAPIをAWS Lambda1などで作成し、そこからSesame APIを叩いて鍵のアンロックを実現します。
それさえできれば、NFCタグを自宅のドアなどに貼っておけば、iPhoneをそのNFCタグにタッチして鍵をロック/アンロックできるようになるはずです。
この記事は実験レベルでセキュリティを考慮していません。例えばこの記事で作ったURLを誰かに知られてしまうと、誰でも鍵を開けることができてしまうため、絶対にこのまま実用しないでください！ Sesame APIの利用 APIキーの取得 Sesame APIを叩くうえで必要なAPIキーやSesame ID（device_id）の取得方法についてはCANDY HOUSEのオフィシャルブログ
https://ameblo.jp/candyhouse-inc/entry-12416936959.html
をご参照ください。
API仕様 Sesame APIの仕様については https://docs.candyhouse.co/ にきちんとしたドキュメントがあります。
curlで叩いてみる curl -H &amp;quot;Authorization: YOUR_AUTH_TOKEN&amp;quot; \ https://api.candyhouse.co/public/sesames で、管理しているデバイスのリストが取得できます。 YOUR_AUTH_TOKENはAPIキーに置き換えてください。
レスポンス例 [{&amp;quot;device_id&amp;quot;: &amp;quot;aaaaaaaa-aaaa-aaaa-1111-111111111111&amp;quot;, &amp;quot;serial&amp;quot;: &amp;quot;ABCDEFG&amp;quot;, &amp;quot;nickname&amp;quot;: &amp;quot;\u30c9\u30a2&amp;quot;}] 鍵をロック 上で取得したdevice_idを利用し、
curl -H &amp;quot;Authorization: YOUR_AUTH_TOKEN&amp;quot; \ -H &amp;quot;Content-Type: application/json&amp;quot; \ -X POST -d &#39;{&amp;quot;command&amp;quot;:&amp;quot;lock&amp;quot;}&#39; \ https://api.candyhouse.co/public/sesame/YOUR_DEVICE_ID とするだけです。
鍵をアンロック 同じく、
curl -H &amp;quot;Authorization: YOUR_AUTH_TOKEN&amp;quot; \ -H &amp;quot;Content-Type: application/json&amp;quot; \ -X POST -d &#39;{&amp;quot;command&amp;quot;:&amp;quot;unlock&amp;quot;}&#39; \ https://api.</description>
    </item>
    
    <item>
      <title>NFCタグ で鍵を開けよう（1） NFCタグにURIを書き込む</title>
      <link>https://www.tokoro.me/posts/nfc-iphone-1/</link>
      <pubDate>Mon, 01 Apr 2019 12:43:04 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/nfc-iphone-1/</guid>
      <description>この記事は「NFCタグ で鍵を開けよう」シリーズの第1弾です。 以下、5つの記事に分けて投稿していく予定です。
NFCタグにURIを書き込む（この記事） iPhoneを鍵とし、ドアにNFCタグを設置するパターン iOSアプリを経由してセキュリティレベルをあげる NFCタグを鍵とし、ドアにNFCリーダーを設置するパターン（まだ書いてないけど気が向いたら書くかも） より実用的にしていくために iOS13時代の最終形 導入 我が家にスマートロックのSesameを採用しました。
私一人ならSesameだけでものすごく便利になったわけですが、我が家には小さい子供が３人います。子供たちにスマホを持たせるにはまだ早く、このままではスマートロックの恩恵を十分に受けることができません。
なお、Sesameは個人が触れる便利なAPIを公開してくれています。NFC＋Sesame APIでこの状況を改善できるものではないか、と思い立ったのがこの記事を書くきっかけです。まだ現在進行形で実験中ですが、実験した結果を随時記事にしていければと考えています。
この記事でやること 私がNFCタグを取り扱ったことがないところからスタートしましたので、まずこの記事では「NFCタグに情報を書き込む」ところまでだけが範囲になります。
実際にSesameをアンロックするところなどは次の記事で書かせていただきます。
準備した機器 スマートロック 導入に書いたとおりですが、Sesameを購入しました。
APIでのロックやアンロックが可能で自由度が高そうだったのがSesameを選んだ理由です。
利用するNFCタグ サンワサプライ NFCタグ(10枚入り)をAmazonで購入しました。
NFCリーダー/ライター NFCリーダー/ライターとしてはPaSoRiを購入しました。
これも使えればどれでも良いと思いますが、ネット上で利用実績が多く安全そうなものを選んだだけです。
nfcpyでNFCタグの情報を扱う まずはMacにNFCリーダーを接続してNFCタグから情報を読み取るところからはじめます。
調べたところnfcpyというツールがよく使われているようです。 実際に使ってみたところ確かに簡単に利用でき、読み取りから書き込みまでこれで全て完結できそうです。
このツールのexamplesフォルダにそのまま使える便利なサンプルがたくさん入っていました。
情報の読み取り NFCタグに書き込まれた情報を読み取るにはexsamplesの中のtagtool.pyを使って
python tagtool.py show とするだけです。
フォーマット NFCタグをフォーマットしたいときもtagtool.pyを使って
python tagtool.py format とするだけです。
URI書き込み NFCタグにURIを書き込みたい場合のみ少し工夫が必要でした。 とはいえ、exsamplesの中にあるものだけで改造なしで可能です。
例えばhttps://tag.exsample.com/lockというURIを書き込むこととします。
まず、うまくいくパターンからですが、
echo -n \\0x04tag.exsample.com/lock | python ndeftool.py pack -t urn:nfc:wkt:U - | python tagtool.py load - でURIを書き込み可能です。 まず、NFCタグに書き込む情報はNDEF（NFC Data Exchange Format）でないといけないようです。NDEFではText、URI、SmartPosterなどのRecord Typeを扱えます。</description>
    </item>
    
    <item>
      <title>Vimで技術書を執筆する環境 with Re:VIEW &#43; RedPen &#43; prh</title>
      <link>https://www.tokoro.me/posts/vim-review/</link>
      <pubDate>Fri, 21 Dec 2018 10:14:52 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/vim-review/</guid>
      <description>本記事は Vim その2 アドベントカレンダー 21日目の記事です。
経緯 今年の8月頃から PEAKS の iOS 12 Programming という技術書の執筆に参加しました。 このとき初めて Re:VIEW による執筆をしました。
現在は技術書展も賑わっており、Re:VIEWで執筆する機会は以前より多くなっているかと思います。 一方で、VimでRe:VIEWを取り扱う環境が意外と整っておらず1、2018年時点の情報を整理させていただきます。
以下、
シンタックス・ハイライト リアルタイムプレビュー 校正サポート コード・スニペット の順に整理いたします。
シンタックス・ハイライト Re:VIEWのシンタックス・ハイライト用のpluginはいくつか見つかったものの、最新のRe:VIEW 2.0にきっちり対応されているものが見つかりませんでした。 Re:VIEW 2.0のフォーマットガイドはこちらです &amp;gt; https://github.com/kmuto/review/blob/v2-stable/doc/format.ja.md
そのため、Re:VIEW 2.0に一通り対応したものを作って利用しました。
https://github.com/tokorom/vim-review このついでに、Re:VIEW内に埋め込んだソースコードのハイライトにも対応させています。 例えば、私の今回の執筆ではSwiftコードを使っていますので、その場合は、
let g:vim_review#include_filetypes = [&#39;swift&#39;] と、既存のfiletypeであるswiftをg:vim_review#include_filetypesに指定してあげるだけです。 これで、
と、文章内に埋め込まれたソースコードもきっちりハイライトされます。
これが発火する条件は、
Re:VIEWのブロック命令としてlist、listnum、emlist、emlistnumのいずれかを利用し、言語指定として設定済みのfiletypeを指定していること です。
リアリタイムプレビュー Re:Viewのリアルタイムプレビューをgulp/gruntのlivereloadを使わずにbrowser-syncとfswatchだけでやる を真似させていただきました。
fswatch browser-sync を利用します。 こちらはVimで、というよりはシンプルにファイルの変更を監視してhtmlを出力＆プレビューするだけです。
fswatchでreファイルの変更を監視して変更があればhtmlを出力 そのhtmlをbrowser-syncでブラウザでライブリロード という手順です。
事前準備 brew install fswatch npm install -g browser-sync browser-syncの起動 cd articles browser-sync start --server --files *.</description>
    </item>
    
    <item>
      <title>Lottieでアプリにアニメーションを組み込む話（iOSプログラマー編）</title>
      <link>https://www.tokoro.me/posts/lottie-ios-1/</link>
      <pubDate>Wed, 06 Jun 2018 14:09:34 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/lottie-ios-1/</guid>
      <description>この記事について この記事は Lottieでアプリにアニメーションを組み込む話（デザイナー編） を受けての iOSプログラマー編 になります。 デザイナー編では実際にアニメーションを作る具体的な方法を含め解説されていますので是非ご参照ください。
Lottieとは LottieとはAdobe After Effectsで作ったアニメーションをそのままクライアントアプリで表示するためのライブラリです。 iOSやAndroidのネイティブアプリの他、React Nativeでも利用できます。
iOS用のライブラリは、
https://github.com/airbnb/lottie-ios
です。
なにができるの？ 作成されたアニメーション用JSONファイルをアプリに埋め込んでわずかなコードで再生することができる インターネット上に設置したJSONファイルを読み込んでアニメーションを再生することもできる アニメーションはリピート再生のほか、逆転再生やアニメーションスピードの調整もできる プログラムで任意のフレームまで、もしくは任意のフレームから再生することもできる 動的にアニメーション内の要素の色や位置を変更することができる 動的にアニメーション内にUIViewサブクラスを埋め込める UIViewControllerのトランジッションでも利用できる GIFアニメなどより軽くて綺麗 iOSアプリでプログラムで作るよりもいいの？ もちろん、同じことをiOSアプリ内でプログラムで実現しても良いとは思います。しかし、
これまでアプリプログラマーが実装していた部分をデザイナーさんにお任せするという選択肢ができる Androidや他のプラットフォーム上で同じアニメーションファイルをそのまま利用できる プログラム内のアニメーション（View）のための複雑なコードを省略できる ことは、多くのチームでメリットとなり得るでしょう。
事前準備 CarthageやCocoaPodsでlottie-iosをプロジェクトに追加します（方法については省略します）。
アニメーションを表示してみる JSONファイルの埋め込み 再生したいアニメーションJSONをアプリに埋め込むには、単純にXcodeのプロジェクトにドラッグ＆ドロップなどして追加するだけでOKです。1
再生するコード import Lottie let animationView = LOTAnimationView(name: &amp;quot;yes&amp;quot;) animationView.frame = view.bounds view.addSubview(animationView) animationView.play() 再生するのは本当に簡単で、Lottieをimportし、LOTAnimationViewをJSONファイル名指定で作成し、addSubviewしてplay()するだけです。
なお、LOTAnimationViewのframeは適切な大きさに設定する必要があり、デフォルトでは設定したframeの大きさでアニメーションが拡縮されて再生されてしまいます。2
上のサンプルはサイズを考えずにaddSubviewしており、
のように意図しない大きさで再生されてしまいます。
アニメーションのサイズを知る アニメーションのサイズを知るには、
作成したデザイナーさんに聞く アニメーションのJSONファイルを覗いて調べる 他、プログラムで取得することもできます。
animationView.frame = animationView.sceneModel?.compBounds ?? view.bounds LOTAnimationViewにはsceneModelプロパティがあり、このプロパティからアニメーションに関する情報を参照できます。 サイズに関してはcompBoundsプロパティを見ればOKです。
インターネット上にJSONを設置する 必要なら、アプリに埋め込まずにインターネット上のアニメーションJSONを参照し、後からアプリのバージョンアップなしでアニメーションを変更することもできます。
let animationJSON = &amp;quot;https://example.</description>
    </item>
    
    <item>
      <title>[HomeKit対応仕様] デロンギ マルチダイナミックヒーター</title>
      <link>https://www.tokoro.me/posts/homekit_delongi_heater/</link>
      <pubDate>Thu, 08 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/homekit_delongi_heater/</guid>
      <description>De&amp;rsquo;Longhi Multi Dynamic Heater WiFi Model
主なサービス HMServiceType〜 説明 Thermostat サーモスタット 主なキャラクタ HMCharacteristicType〜 説明 フォーマット 書き込み CurrentHeatingCooling 現在の冷暖房の状態 uint8 - TargetHeatingCooling 冷暖房の目標状態 uint8 可 CurrentTemperature 現在の温度 float - TargetTemperature 目標温度 float 可 TemperatureUnits 温度表示装置 uint8 可 概要 ちょっとお高くて（Apple Storeで￥84,800）試用レベルではなかなか買えないHomeKit製品の代表格かと思います。 私の知っている限りでは、一番高額なHomeKit対応製品です1。
私はきちんと詳細把握していないのですが純粋にヒーターとしても高性能らしく、第３のヒーターとも言われているようです（参考）。
公開されている情報と、この機器を実際に利用しているUIデザイナーの元山さんの感覚をもとにメリットを並べると、一般的なエアコン暖房と比較して
温度を一定に保つ能力が高い 静か 乾燥しない といった特徴があります。 私もワークスペースで一緒に使わせていただいているわけですが、実際に稼働しているかどうかわからないくらい静かで、暖房が付いているという感覚がありません。
一方で、他の実際に利用している知り合いの感想として「あまり暖かくなっている感じがしないので、結局、石油ヒーターのほうを使っている」というものもありました。
自然に適温な空間を作りたいのか、もっと直接的に暖まりたいのかなどの好みによっても利用感が変わってくるのかもしれません。
なおHomeKitのサービスとしては主にはサーモスタットのみで、書き込み可能なキャラクタとして「暖房機能のOn/Off」「目標温度」「温度表示装置のOn/Off」などがあります。
また、隠し機能（というかHomeKitでは定義されていないカスタムキャラクタ）としてEco Modeなど14つのカスタムキャラクタもありますので、解析すればより細かい制御ができると思います。
暖房をOnにするには？ 温度の設定はCurrentTemperature（目標温度）を上書きすれば良さそうですが、暖房をOnにするにはどうすれば良いでしょう？ この機器には他の機器によくあるPowerState（電源の状態）キャラクタがありません。
また、TargetHeatingCooling（冷暖房の目標状態）というキャラクタがありますが、この機器に冷房機能はないんですが？
といった時にはキャラクタのmetadataプロパティを参照すれば明確になることが多いです。例えばこの機器のTargetHeatingCoolingキャラクタのmetadataは以下になっていました。
プロパティ 実際の値 format uint8 units minimumValue 0 maximumValue 1 stepValue 1 validValues maxLength このキャラクタのvalueには数値で0 or 1を指定できるようです。 実際に以下のコードで 1 を指定すると暖房がOnになりました。</description>
    </item>
    
    <item>
      <title>[HomeKit対応仕様] Philips Hue モーションセンサー</title>
      <link>https://www.tokoro.me/posts/homekit_hue_sensor/</link>
      <pubDate>Thu, 01 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/homekit_hue_sensor/</guid>
      <description>Philips Hue モーションセンサー
主なサービス HMServiceType〜 説明 MotionSensor モーションセンサー LightSensor 光センサー TemperatureSensor 温度センサー 主なキャラクタ HMCharacteristicType〜 説明 フォーマット 書き込み MotionDetected 動きを検知 bool - CurrentLightLevel 現在の光量 float - BatteryLevel 電池残量 uint8 - CurrentTemperature 現在の温度 float - ChargingState 充電の状態 uint8 - StatusLowBattery 状況（電池残量低下） uint8 - 概要 日本で普通に購入できるモーションセンサーとしては Elgato Eve Motion に次ぐ待望の２つめです。
しかも、Eve Motionが6000円だったのと比較するとこちらは4000円台で購入可能で、しかも光センサーや温度センサーまで付いているという豪華仕様です。 また、（HomeKitとは直接関係ありませんが）Hueのライトとの相性はとにかくよく、
モーションを検知して点灯してから何分後に消灯するか設定でき、かつ、完全消灯の前にうっすら暗くなるフェーズが入る 光センサーによりどのくらいの暗さなら点灯するかを設定できる といったことが可能で、この２点によりライトの自動点灯用としてはEve Motionよりも圧倒的に優れています。 特に「完全消灯の前にうっすら暗くなるフェーズが入る」のが地味に大切で、トイレなどで使っているときにいきなり真っ暗になるのを防ぎ、少し暗くなったらちょっと動いてライトを復活させるといった猶予が作れます。
ということでEve Motionと比較すると機能的には圧倒的に優れているわけですが、唯一のネックはHueのブリッジが必要というところです。 逆にHueのブリッジを導入済みならこちら一択かと。。。
もちろん電池残量関連のキャラクタも参照可能です。
現在の光量を条件に加えるサンプルコード このセンサーの設定はHueアプリで完結できるのですが、せっかくなので光センサーを使って「現在の光量がNより下の場合」だけ「モーションを検知したらライトを点灯する」というサンプルコードを紹介します。
let home: HMHome = //&amp;lt; 任意のHome let lightLevel: HMCharacteristic = //&amp;lt; HMCharacteristicTypeCurrentLightLevel let motionDetected: HMCharacteristic = //&amp;lt; HMCharacteristicTypeMotionDetected // 現在が15ルクスより暗い場合という条件 let predicate = HMEventTrigger.</description>
    </item>
    
    <item>
      <title>[HomeKit対応仕様] Koogeek Wi-Fiスマート LED</title>
      <link>https://www.tokoro.me/posts/homekit_koogeek_lightbulb/</link>
      <pubDate>Tue, 02 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/homekit_koogeek_lightbulb/</guid>
      <description>Koogeek Wi-Fiスマート LED HomeKit 電球 E26 8W 1600万色変色可能 調光調色
主なサービス HMServiceType〜 説明 Lightbulb 電球 主なキャラクタ HMCharacteristicType〜 説明 フォーマット 書き込み PowerState 電源の状態 bool 可 Hue 色相 float 可 Saturation 彩度 float 可 Brightness 明るさ int 可 概要 HomeKitのサービス/キャラクタ的には iOS 11 Programming で紹介されているPhilips Hueのランプ（カラー版）と同じです。 そのためHomeKitで操作できる事項もHueと全く同じで、電源のOn/Off、色（色相、彩度、明るさ）が変更可能です。
Hueどっちが良い？ まず、カラー版の値段はKoogeekのランプのほうがだいぶ安いです。またHueのようにブリッジが必要なく単体で動作するところもメリットになり得ます。 そのため、HomeKitをちょっと試したいくらいであればKoogeekのほうが圧倒的に優位かもしれません。
一方で、Hueのほうが 各種APIが充実している など一日の長があります。 既にHueのブリッジを所持している、追加のランプはカラー版でなく安いホワイトグラデーションのほうで良いなどあればHueが優位になってきます。 また、計測情報などもなくどのくらいの差があるかはわかりませんが、単体で動作しWi-Fi通信を行うKoogeekのランプに比べ、ZigBeeで通信するHueのランプのほうが日々の電気代は安くなるかもしれません。
まずは試してみたいという感覚なのか、本格的に長期で使っていきたいのかなどによって選択は変わってくるかと思います。
参考: スマートホーム×DIY 実践と展望 〜 2. 実践Homekitの暮らし（実際に自宅でHueとKoogeekを一緒に利用しての所感が書かれた記事）
ライトの電源をOnにするサンプルコード ライトを点けたり消したりする程度の設定はホームアプリ上でGUIで設定できるわけですが、参考までに敢えてこれをプログラムで実現する場合は以下のようにします。
// Koogeek LightBulbのpowerStateを取得 let powerState = //&amp;lt; HMCharacteristicTypePowerState // 電源をOnにする powerState.</description>
    </item>
    
    <item>
      <title>テレビのリモコンのことも忘れないで！</title>
      <link>https://www.tokoro.me/posts/tvos_advent_calendar_2/</link>
      <pubDate>Sun, 24 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/tvos_advent_calendar_2/</guid>
      <description>AppleTVで使えるリモコンって？ Siriリモート tvOS/AppleTVのリモコンといえばSiriリモートですよね。 皆様におかれましても日々のAppleTV生活ではSiriリモートを使われているかと思います。
テレビのリモコン そしてもちろん普通のテレビのリモコンもAppleTVの操作に使えます！
AppleTVを利用しているということは当然テレビを利用しているわけで、AppleTVを使っている人のほとんどがテレビのリモコンを所持している、かつ普段使いしていることでしょう（AppleTVの操作をするかどうかは置いておいて）。 そのため、AppleTVの操作という意味ではSiriリモートに次いで利用するチャンスが多くなるリモコンかと思います。
ゲームコントローラ/ゲームパッド Nimbusなどのゲームコントローラも利用できますが、今回の主役は普通のテレビのリモコンのため、省略させていただきます。
テレビのリモコンでどこまで操作できる？ Apple純正のアプリ 全て確認したわけではないですが、ホーム画面はもちろん、純正アプリならテレビのリモコンだけでも一通りの操作ができるようになっているようです。
サードパーティのアプリ ゲームアプリ以外なら操作できることが多いようです。 ただしTouchサーフェス前提で組まれているアプリは操作不能です。
自分が開発するアプリはどうすべき？ タイトルには「忘れないで！」と書いたものの、実際のところそんなに気にしなくても良いのでは。 また、UIKitをシンプルに使って作ったアプリなら何も処置しなくてもテレビのリモコンで操作できるようになっています（後述します）。
テレビのリモコンのボタンに対応するUIPressType うちのテレビ（REGZA）のリモコンではこんな感じになっていました。他のテレビのリモコンも概ね同じじゃないかと思います。
REGZAのリモコン UIPressType 決定 .select 戻る .menu 再生 .playPause 停止 - 上 .upArrow 下 .downArrow 左 .leftArrow 右 .rightArrow UIKitの各コントロールの挙動 フォーカス移動 テレビのリモコンの上下左右キーが有効ですので、上下左右を押すことで普通にフォーカスが移動可能です。そのためシンプルにフォーカスが当たるコントロール（UIButtonなど）が配置されただけの画面なら何もしなくても操作可能になっています。
UITableView/UICollectionView UITableViewやUICollectionViewを使った画面もテレビのリモコンで操作可能です。 デフォルトで各Cellにフォーカスが当たるので、Cellのフォーカスを移動していくと自動的にスクロールしていく挙動になります。
UIPageViewController これは意外だったのですが、UIPageViewControllerもデフォルトでテレビのリモコンでの操作が可能でした。
ただし条件があり、transitionStyleプロパティにUIPageViewControllerTransitionStyle.scrollを設定している場合のみ操作可能です。.pageCurlだと（デフォルトでは）操作不能でした。
.scrollの場合には、navigationOrientationプロパティが.horizontalなら左右ボタンで、.verticalなら上下ボタンでそれぞれページ移動が可能です。
UIScrollView UIScrollViewも特に意識しないでも操作可能になっています。
上下左右で直接スクロール可能というわけではなく、UIScrollView上に配置された要素を上下左右ボタンでフォーカス移動することで、結果としてスクロールされるという挙動になります（フォーカスが当たった要素が画面内に収まるように）。
UITextView UITextViewはデフォルトでは上下左右ボタンでの操作ができませんでした。
テレビのリモコンで操作できない画面をなんとかする 一例ですが、UIPanGestureRecognizerを使って独自のページ移動をさせるような実装をした画面でもテレビのリモコンで操作させたい場合には、UITapGestureRecognizerを使って対処するのが簡単そうです。
let leftTap = UITapGestureRecognizer(target: self, action: #selector(self.leftArrowDidPress(sender:))) leftTap.allowedPressTypes = [NSNumber(value: UIPressType.leftArrow.rawValue)] view.addGestureRecognizer(leftTap) let rightTap = UITapGestureRecognizer(target: self, action: #selector(self.</description>
    </item>
    
    <item>
      <title>tvOSフォーカスクイズ！ ここでスワイプしたらどちらに動く？</title>
      <link>https://www.tokoro.me/posts/tvos_advent_calendar_1/</link>
      <pubDate>Fri, 22 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/tvos_advent_calendar_1/</guid>
      <description>[問題]コンテンツのスワイプ まずは、tvOSの特定の画面にて「右スワイプ」をした時に、コンテンツが左右どちらに動くでしょう？というクイズを３つ出させていただきます。 クイズの問題を３つ出した後に、それらの答えを実際の動きを撮影したGIFアニメとともに並べてありますので、答えのGIFアニメをできるだけ見ないように考えてみてください！
いずれもApple純正アプリ（ホーム画面含む）からの問題です。
Q1. ホーム画面のTop Shelfでの左右スワイプ 最初の問題はホーム画面からです。 このtvOSのホーム画面のTop Shelfで「右スワイプ」をした場合、Top Shelfは左に動いて右隣のコンテンツが表示されるでしょうか？それとも右に動いて左隣のコンテンツが表示されるでしょうか？
Q2. 写真アプリのフルスクリーン画面での左右スワイプ 次の問題は写真アプリの写真をフルスクリーン表示した画面からです。 この 2 という画像が表示されている画面で「右スワイプ」した場合、画像が左に動いて右隣の 3 が表示されるでしょうか？それとも画像が右に動いて左隣の 1 が表示されるでしょうか？
Q3. Appスイッチャーでの左右スワイプ 次の問題はホーム画面のAppスイッチャー（TV/ホームボタンの2度押しで表示される画面）です。 この ミュージック がセンターに表示されているAppスイッチャーで「右スワイプ」した場合、 ミュージック は左に動くでしょうか？それとも右に動くでしょうか？
[答え]コンテンツのスワイプ A1. ホーム画面のTop Shelfでの左右スワイプ まず、Top Shelfで「右スワイプ」した時の挙動ですが、
Top Shelfが左に動き 右隣のコンテンツが表示される というのが答えです。
tvOSには「フォーカス」の存在があり、「フォーカスが右スワイプにより右に移動する」わけなので右隣のものが表示されて当然ですよね。 そして右隣のコンテンツがセンターに表示されるようTop Shelfは左にスクロールします。
A2. 写真アプリのフルスクリーン画面での左右スワイプ さて、Q1の答えは「左に動いて右隣のものが表示される」という挙動でしたが、次の写真アプリの挙動はどうでしょう？
実際にこの写真アプリのフルスクリーン画面で「右スワイプ」を試した結果の挙動は、
表示されていた 2 が右に動き 左隣の 1 が表示される でした！
あれ？Q1の答えと逆の動きだ&amp;hellip;
A3. Appスイッチャーでの左右スワイプ 続いてQ3のAppスイッチャーでの挙動はどうでしょう？
Appスイッチャーで「右スワイプ」したときの挙動は、
表示されていた ミュージック が右に動き 左隣のアプリが表示される こちらもQ1の答えの「フォーカスが右スワイプにより右に移動する」という挙動とは逆ですね。
フォーカスどこいった！？
[問題]トップバーの表示 ここまでの３問の答えに「いや当然だろ」と思ったかたも、「あれ？」と思ったかたもいらっしゃるかと思います。 いったん細かいことを気にせずに、次の「トップバーを表示する方法」のクイズにいかせていただきます。
※基本的にはタブバーと思いますが、今回のサンプルの全てがタブばーかどうかの確証がなかったため、画面トップに表示されるトップバーという表現をさせていただきます
Q4. 写真アプリの写真一覧画面でのトップバー表示 まずは写真アプリからの問題です。 写真アプリの写真一覧画面で、画面上部の１つの写真にフォーカスが当たっている状態とします。</description>
    </item>
    
    <item>
      <title>クリスマスツリーをHomeKitに対応させよう</title>
      <link>https://www.tokoro.me/posts/homekit_christmastree/</link>
      <pubDate>Thu, 14 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/homekit_christmastree/</guid>
      <description>やりたいこと 必須要件 日の入りあたりで自動的にクリスマスツリーのライトを自動点灯する 24:00など時間がきたらクリスマスツリーのライトを自動消灯する あったらいいね Siriでクリスマスツリーを点灯/消灯する 屋外のクリスマスツリー用に防雨対応する これまで HomeKitなど使わなくても実利用的には オーム電機(OHM) S-OCDSTM7A [防雨型 光センサータイマーコンセント 700W] などの光センサーを利用するので十分かと思います。
今のところHomeKit化しなければいけない理由は大きくないですが、せっかくなので&amp;hellip;ということで。
実現方法 クリスマスツリーをHomeKit対応する、といっても実際にはクリスマスツリーのライトのコンセントを Koogeek スマートコンセント などのHomeKit対応スマートコンセントに繋ぐだけです。
これを利用することでHomeKitの設定により、
日の入りの前後でクリスマスツリーを点灯（スマートコンセントの電源をOn）する 設定時間でクリスマスツリーを消灯（スマートコンセントの電源をOff）する Siriでクリスマスツリーを点灯/消灯（スマートコンセントの電源をOn/Off）する などが実現できます。
なお、Koogeekのスマートコンセントの利用実例は iOS 11 Programming でも詳細に紹介しています。
オートメーションの設定 これらオートメーションの設定は自分でプログラミングして追加することももちろん可能ですが、この程度のものならHomeアプリを使って設定可能です。
このレベルなら設定も本当に簡単で、オートメーションタブから追加ボタンを押して上のスクショのような設定を２つ追加するだけです。
防雨対応 クリスマスツリーを室内で運用するならこれでおしまいですが、屋外に設置する場合は防雨対策をしなければなりません。
はじめは 防雨型コンセントボックス など専用のコンセントボックスを利用しようと思っていましたが、UIデザイナーの元山くんから「そんなのバケツをひっくり返してのせとけばいいんじゃないですか？」と指摘され、まあ、それもそうかなと思い、もうちょっと安く済ませる方針としました。
さすがにバケツはあれなので、100円均一のお店で適当な大きさのプラスチックのケースとビニールテープを買ってきました。
プラスチックケースはそのままだとコンセントのケーブルが通りませんので、ノコギリで少し切り込みを入れて、そこにケーブルを通すようにしました。
あとは蓋を閉めて、ビニールテープで先ほどの切り込みを含めて巻いておしまい、という簡便なものです。
実際、普通の雨ならこれで十分な感じです。
（なお、水滴がケース内に発生して云々&amp;hellip;など深くは確認していないので同じ方法を採用するかたは自己責任で&amp;hellip;）
まとめ 前述のとおりHomeKitでなくても実用的には十分なのですが、HomeKit対応することで（強いて言えば）以下のメリットがあります。
「日の入り」というトリガーが使え、光センサーによるトリガーよりも精度が高い 例えばSiriで「メリークリスマス！」と言うことでクリスマスツリーを点灯させるなど、子どもたちの喜びそうなイベントに使えそう 自宅に不在時は点灯させないなどプレゼンス関係の条件付けも可能 他の点灯条件が揃ってなくても自分が帰宅してきたときには点灯させるなど自己満足な設定も可能 HomeKit対応させてiOSプログラマー的には気分が上がる iOSプログラマーのお父さん、お母さん、ぜひお子さんたちの喜ぶクリスマスツリーをHomeKitで作りましょう！</description>
    </item>
    
    <item>
      <title>[HomeKit対応仕様] Philips Hue Dimmer スイッチ</title>
      <link>https://www.tokoro.me/posts/homekit_hue_dimmer_switch/</link>
      <pubDate>Fri, 01 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/homekit_hue_dimmer_switch/</guid>
      <description>[Amazon] Philips Hue(ヒュー) Dimmer スイッチ
主なサービス HMServiceType〜 説明 StatelessProgrammableSwitch ステートレス・プログラマブル・スイッチ Battery バッテリー 主なキャラクタ HMCharacteristicType〜 説明 フォーマット 書き込み InputEvent プログラマブル・スイッチ・イベント uint8 - BatteryLevel 電池残量 uint8 - ChargingState 充電の状態 uint8 - StatusLowBattery 状況（電池残量低下） uint8 - 概要 スマートIoT照明のパイオニアであるPhilips Hueのランプのプログラマブルスイッチです。
Hueの公式ページにもAppleのHomeKit対応製品一覧にもこの製品がHomeKit対応しているとは書かれていなかったのですが、購入して利用してみたらHomeKit対応していて驚きました。 単体で買えば3000円程度とHomeKit対応したプログラマブルスイッチとしては格安です。
なお、この製品を動作させるにはHueのブリッジが必要であることに注意が必要です。 逆に、Hueのブリッジがあれば、Hue以外の（HomeKit対応した）ランプのコントロールにも利用できます。 HomeKit的には単なるプログラマブルスイッチですので、ランプの点灯/消灯以外のあらゆる操作にも対応可能です。
この製品は電池で動作しますので電池残量関連のキャラクタも参照可能です。
InputEventをトリガーとするサンプルコード InputEventをトリガーとして特定のシーンを実行する、具体的には、ボタンを押したらランプを点灯/消灯するサンプルコードを紹介します。
なお、単にシーンを実行するだけならコードを書かなくともApple純正のHomeアプリで設定できますので、ここでは、
ランプが消灯していれば点灯する ランプが点灯していれば消灯する とトグルになるサンプルとします。
// 設定したいボタンのInputEventを探す // このサンプルでは適当な１つのInputEventを取得 let service = home.servicesWithTypes([HMServiceTypeStatelessProgrammableSwitch])?.first let candidates = service?.characteristics.filter { $0.characteristicType == HMCharacteristicTypeInputEvent } guard let inputEvent = candidates?.first else { return } // InputEventが取り得る値は0のみ let event = HMCharacteristicEvent(characteristic: inputEvent, triggerValue: NSNumber(value: 0)) let powerState = //&amp;lt; チェック対象のランプのPowerStateキャラクタ // ランプが点灯中の場合という条件を作る let onState = HMEventTrigger.</description>
    </item>
    
    <item>
      <title>[HomeKit対応仕様] Philips Hue ホワイトグラデーション シングルランプ</title>
      <link>https://www.tokoro.me/posts/homekit_hue_white_lamp/</link>
      <pubDate>Wed, 22 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/homekit_hue_white_lamp/</guid>
      <description>[Amazon] Philips Hue(ヒュー) ホワイトグラデーション シングルランプ
主なサービス HMServiceType〜 説明 Lightbulb 電球 主なキャラクタ HMCharacteristicType〜 説明 フォーマット 書き込み PowerState 電源の状態 bool 可 ColorTemperature 色温度 int 可 Brightness 明るさ int 可 概要 スマートIoT照明のパイオニアであるPhilips Hueのランプの非カラー版です。 非カラーといっても、蛍光灯のような白色から白熱電球のようなオレンジ色の温かみのある色まで調整できます。
カラー版ではHue、Saturation、Brightnessの３つのキャラクタを変更することでランプの色を変えますが、この非カラー版ではColorTemperatureという１つのキャラクタを変更することで色味を調整します。
なおHMCharacteristicTypeColorTemperatureはiOS 11で新規追加されたキャラクタです。
もちろんPowerStateキャラクタで点灯/消灯を操作することもできます。
ColorTemperatureのmetadata プロパティ 実際の値 format int units minimumValue 153 maximumValue 454 stepValue 1 validValues maxLength manufacturerDescription Color Temperature ColorTemperatureのvalue valueプロパティは153から454の範囲で設定できます。 この写真の左側のランプが153を、右側のランプが454を設定した時の実際の色味です。
ColorTemperatureを更新するサンプルコード let service = home.servicesWithTypes([HMServiceTypeLightbulb])?.first let candidates = service?.characteristics.filter { $0.characteristicType == HMCharacteristicTypeColorTemperature } guard let colorTemperature = candidates?</description>
    </item>
    
    <item>
      <title>iOS 10でついに通知許可ダイアログの操作をハンドリングできるようになったよ</title>
      <link>https://www.tokoro.me/posts/user_notification/</link>
      <pubDate>Tue, 28 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/user_notification/</guid>
      <description>概要 エンドユーザーが通知（特にRemote Push Notification）を許可してくれたかどうかはサービスにとって死活問題 それなのに通知の許可ダイアログでの選択を素直にハンドリングする方法がこれまでなかった iOS 10でそれを簡単にハンドリングできるようになったよ！ 2016/6/28 追記
コメントで @mono0926 さんからいただいたとおり、じつはiOS 8/9でもdelegateでハンドリング可能ということが発覚しました。
http://qiita.com/tokorom/items/6c6864fa8e841e50e37b#comment-b07920917a7edfb87775
iOS 8/9 でのハンドリングについては別途まとめさせていただきますが、取り急ぎ、こちらで訂正させていただきます。
iOS 9 以前 let notificationSettings = UIUserNotificationSettings(forTypes: [.Alert, .Badge, .Sound], categories: nil) UIApplication.sharedApplication().registerUserNotificationSettings(notificationSettings) でiOSが必要なら
とエンドユーザにこのアプリが通知機能を使うことを許可するかどうかを確認するダイアログを表示していました。
しかしこのrequestは投げっぱなしのため、実際にそのダイアログが表示されたタイミングもプログラム的には検知できませんし、このダイアログに対してユーザーが実際に許可（Allow）をしたのかしなかったのかも、その瞬間にハンドリングすることが難しいという問題がありました。
（やるとすると少し間をおいて通知設定を確認するなどスマートでない方法&amp;hellip;）
iOS 10 でこうなる しかしiOS 10で導入されたUser Notifications Frameworkにより、これを正確にハンドリングすることができるようになったんです。 具体的には、
UNUserNotificationCenter.current().requestAuthorization([.alert, .badge, .sound]) { (granted, _) in // got granted :) } でこれまでと同じくiOSの判断で確認ダイアログが表示されます。
ただ素晴らしいことに（というかようやく）このrequestAuthorizationの第2引数のclosureは、この許可ダイアログでエンドユーザがAllowもしくはDon&#39;t Allowを選択したタイミングでコールバックされるんです！そしてその引数（上の例だとgranted）にAllowとDon&#39;t Allowのどちらが選択されたかが渡されます。
コールバックされるタイミングとgrantedの値のまとめ なお、すでに許可の判断が済んでいて、この許可ダイアログが表示されない場合もコールバックされますので、正確にはユーザーの選択がコールバックされるというよりは、その時点での許可の状況がコールバックされるというのが正確な言い方かと思います。 （で、嬉しいのは、許可ダイアログが表示された場合は、許可の判断が終わるまでコールバックを待ってくれるところ）
タイミング granted 許可ダイアログでAllowを選択 true 許可ダイアログでDon&amp;rsquo;t Allowを選択 false request時に既にAllow済み（ダイアログは表示されない） true request時に既にDon&amp;rsquo;t Allow済み（ダイアログは表示されない） false ちなみに第2引数は An object containing error information or nil if no error occurred.</description>
    </item>
    
    <item>
      <title>Swiftのextensionでstored propertyを追加する？（黒魔術は閉じ込める）</title>
      <link>https://www.tokoro.me/posts/has-associated-objects/</link>
      <pubDate>Sun, 08 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/has-associated-objects/</guid>
      <description>extensionでstored propertyを追加したくなることありますか？ 少なくともSwift 2.1時点ではextensionでstored propertyを追加することはできず、computed propertyのみに限られます。
でも、ヤダヤダ！ぼくは絶対stored property追加したいんだい！ってことありますか？
そう思っちゃうあなた、他に解決方法ありますよね？なんでそのやりかたにこだわるんですか？そういう思考になっちゃう時点でまだSwift脳に至ってはいないのではないでしょうか（建前）。
なお、ぼくはどうしても追加したんだい！ってことがあります（本音）。
対象がAnyObjectならAssociated Objectsで代用できるよ で、そんな時は この記事 でやっているように Associated Objects で代用できることがあります。
対象にきちんとretainさせることも可能ですし、安心ですね！
以下、サンプルコードです。
var StoredPropertyKey: UInt8 = 0 extension UIViewController { var storedProperty: SomeObject? { get { guard let object = objc_getAssociatedObject(self, &amp;amp;StoredPropertyKey) as? SomeObject else { return nil } return object } set { objc_setAssociatedObject(self, &amp;amp;StoredPropertyKey, newValue, .OBJC_ASSOCIATION_RETAIN) } } } でも、こんな黒魔術的コードをプロジェクトの各所に書いてしまうと、またみんなに怒られちゃうかもしれませんよ？
黒魔術（臭いもの）にフタを なので、この objc_xxxAssociatedObject を二度と書かなくて良いようにライブラリ化できないものでしょうか？
例えば、こんな感じで気軽にextendできるように。
// UIViewControllerにstoredPropertyを追加！ extension UIViewController: HasAssociatedObjects { var storedProperty: String?</description>
    </item>
    
    <item>
      <title>Swiftでdeinitまで処理をdeferする</title>
      <link>https://www.tokoro.me/posts/defer-to-deinit/</link>
      <pubDate>Mon, 26 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/defer-to-deinit/</guid>
      <description>deferしてますか？ Swift2でみんな大好きdeferさんが導入されましたね！
guardと違いそんなに使う機会は訪れていないのですが、昨日、こんな感じで使いたい！という場面に遭遇しました。
CocoaLumberjackを使ってデバッグ用にUITextViewにログを吐くCustom Loggerを設定していたのですが、とあるViewControllerだけでそれを使いたく、ViewControllerがdeinitされたらそのCustom Loggerも当然外したい。
そんなコードを書く場合、defer大好きっ子ならCustom Loggerを登録した後にこんな感じで解除したくなりますよね（実際は僕はこのとき初めて実験でないところでdeferを使ったので、本当のdefer大好きっ子はこんな間違いはしないだろう）。
let logger = TextViewLogger(textView: textView) DDLog.addLogger(logger) defer { DDLog.removeLogger(logger) } defer使って、必要なくなったら漏れなくCustom Loggerを解放する俺様は超カッコいいぜ！と言いたかったのだが、当然のごとくこのコードは間違っていて、これを実行し終わるときにはdeferした処理も実行されて登録したCustom Loggerが即解除されるというお馬鹿な状況になるわけです。
でもdeferしたいよね？ とお馬鹿な前置きは置いておいても、上のような雰囲気で終処理書けたら便利な気はする。 普通にdeinitでやれば済む話なんだけど、今回のケースだとpropertyにloggerをもたせて、deinitでloggerがあればremoveLoggerする的なことを書かないといけない。まあ普通のことではあるんだけど、できたら、
let logger = TextViewLogger(textView: textView) DDLog.addLogger(logger) deferToDeinit { DDLog.removeLogger(logger) } と、deinitまで処理を遅延させる的な書き方できたら面白いよね、ということで&amp;hellip;
deinitまでdeferさせてみよう！その1 まず、超smellな秘伝のBaseViewControllerを使ってベタにやってみると、
typealias DeferredClosure = () -&amp;gt; Void class BaseViewController: UIViewController { var deferreds: [DeferredClosure] = [] deinit { for deferred in deferreds { deferred() } } func deferToDeinit(closure: DeferredClosure) { deferreds.append(closure) } } てな感じでBaseViewController君を作っておけば、このsubclassではみんなdeferToDeinitが使えるようになって、ひとまず目的は果たせる（はず）。</description>
    </item>
    
    <item>
      <title>El CapitanでTotalTerminalが動かないならAppleScriptで代用すればいいじゃない?</title>
      <link>https://www.tokoro.me/posts/el-capitain-totalterminal/</link>
      <pubDate>Mon, 05 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/el-capitain-totalterminal/</guid>
      <description>El CapitanにしたらTotalTerminalが動かない！ Twitter上でもよくこの話題が出ていて、多くの人はiTerm2に移管しているようです。
しかし、ぼくは長年愛した（普通の）Terminalちゃんをそう簡単に捨てることはできないのです！
もともとTotalTerminalはTerminalの表示をカッコよくトグルするために使っているわけで、TotalTerminalというよりはTerminalちゃんをそのまま使いたいわけです。 （実際のところiTerm2を試してないので、iTerm2の良さについては全くの無知です）
であれば、そんなトグルくらいならAppleScriptで軽やかにできるはず！ぼくのAppleScriptでTerminalちゃんを救ってみせる！ と思いたって試してみました。 （実際のところAppleScriptに無知すぎて全く軽やかにはできなかったわけですが、結果自体はシンプルです）
以下、試したことをまとめます。
ぼくの最強なトグル用AppleScript ひとまずこのスクリプトを実行することで、
Terminalが動いていなければ起動して最前面に Terminalが裏にいるなら最前面に Terminalが最前面にいるなら裏に回す ことはできるようになった。
tell application &amp;quot;System Events&amp;quot; set activeApp to first process where it is frontmost if activeApp&#39;s name = &amp;quot;Terminal&amp;quot; then # Command-Tab tell application &amp;quot;System Events&amp;quot; key down command keystroke tab key up command end tell else # Open Terminal tell application &amp;quot;Terminal&amp;quot; to activate end if end tell 今のぼくにはこれが精一杯でした。 こんなぼくに、もっとこうしたほうが良いよ！と教えてくれるかたがいらっしゃったら、現在のスクリプトをGitHubに置きましたので是非ご指摘いただけると嬉しいです。
https://github.com/tokorom/ToggleTerminalScript
現在の課題としましては、
Terminalが起動しているがウィンドウがないときはウィンドウがないままアクティブになる（困ってはないけど勝手にウィンドウ作ってくれればスマート） かっこよくない（冗長かもだが、TotalTerminalみたいにかっこよく動くとより良い） プロセスの名前が常に Terminal でよいのかがよくわからん Terminalが既にカレントのときにCommand+Tabキーを送って裏に回してるけど、もっとスマートな方法あるんじゃない？ などがありそうです。</description>
    </item>
    
    <item>
      <title>SwiftTask、PromiseKit、Boltsを比較する（2015年3月版）</title>
      <link>https://www.tokoro.me/posts/swifttask-promisekit-bolts/</link>
      <pubDate>Thu, 12 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/swifttask-promisekit-bolts/</guid>
      <description>※2015/3/11時点での比較結果ですので、今後、各ライブラリともにパワーアップしていくと思われます ※いまはできないことでも各ライブラリのIssuesでは実装の検討が進んでいるものも多くあるようです 次の案件で（Swiftで）Promiseライクなフロー制御を実現するために利用するライブラリを選定するため、2015/3/11時点の
SwiftTask PromiseKit Bolts-iOS を（表面だけ）使って比較してみました。
なお、昨年の７月時点では（Swiftで使うぶんには）PromiseKitが将来性があると判断し、しばらくはPromiseKitを使っていました。
その後、SwiftTaskも登場して気になっていたので、今回改めて新案件で採用するライブラリを選定したという経緯になります。
以下にそれぞれ使ってみた結果を紹介させていただきます。
更新頻度 この３つのライブラリはどれも更新頻度が多く、現在betaのSwift 1.2でも（別ブランチで）きちんと動く形になっています。
試すネタ AlamofireでGenericにModelオブジェクトを取得する で試したAlamofireを使うコードをネタとしてそれぞれ３つのライブラリを適用してみました。
Taskを使うほうのコード SwiftTask request(.GET, urlString).success { [unowned self] (users: [User]) in self.textView?.text = &amp;quot;\(users)&amp;quot; }.failure { [unowned self] error, _ in self.textView?.text = &amp;quot;\(error)&amp;quot; } すっきり直感的に書けます Genericsで欲しいModelオブジェクトを直感的に指定するようなインターフェースにできます PromiseKit request(.GET, urlString).then { [unowned self] (users: [User]) -&amp;gt; Void in self.textView?.text = &amp;quot;\(users)&amp;quot; return }.catch { [unowned self] error -&amp;gt; Void in self.textView?.text = &amp;quot;\(error)&amp;quot; return }.</description>
    </item>
    
    <item>
      <title>AlamofireでGenericにModelオブジェクトを取得する</title>
      <link>https://www.tokoro.me/posts/almofire/</link>
      <pubDate>Wed, 11 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/almofire/</guid>
      <description>※この記事のコードはXcode 6.3 beta（Swift 1.2）で試しています
Swiftいいですね！
これまでSwiftの案件を２つほどやってきたのですが、どちらも開発スタートが2014年7月だったため新しめのSwiftライブラリもリスクが高そうで、利用できるライブラリはある程度限定されてしまいました。 例えば、Alamofire のInitial Commitも2014/7/31だったりと。。。
今となっては（2015年3月）Swift公開から早９ヶ月が経過しており、ライブラリの選択肢もだいぶ広がりました。 また、まだSwiftのライブラリを管理する環境もだいぶ整ってきました（ちょうど本日3/11にCocoaPodsのDynamic Framework対応版が公開されました！）。
ということで、３月からはじめる新案件ではAlamofireの採用を決め、APIアクセスまわりのインターフェースをいろいろと検討してみました。 やはりSwiftを使うからには、Genericsを使ってModelオブジェクトに変換された状態のレスポンスを受け取れるインターフェースになっていて欲しいですよね！
※基本的にはAlamofireのREADMEに書かれている話です
ふつうにJSONを取得するインターフェース まず、普通にJSONを取得するインターフェースですが、
Alamofire.request(.GET, &amp;quot;https://api.github.com/users&amp;quot;) .validate() .responseJSON { [unowned self] (_, _, JSON, error) in if let error = error { self.textView?.text = &amp;quot;\(error)&amp;quot; } else if let JSON = JSON { // ここでJSONをパースしてModelに変換する // これは擬似的なコードです if let dicts = JSON as? NSArray { var users = [User]() for dict = dicts { if let user = User(dict: dict) { users.</description>
    </item>
    
    <item>
      <title>NSTimeZoneから取得できる表示用文字列のサンプル</title>
      <link>https://www.tokoro.me/posts/nstimezone-sample/</link>
      <pubDate>Mon, 10 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/nstimezone-sample/</guid>
      <description>さっき、画面上に現在設定されているTime Zoneを表示するって機能を実装していたのですが、NSTimeZoneからどういう文字列が取れるかのサンプルが意外と見つからなかったのでメモします。
abbreviation GMT+9 name Asia/Tokyo description Asia/Tokyo (GMT+9) offset 32400 localizedName(_:locale:) NSLocale NSTimeZoneNameStyle 出力結果 en_US Standard Japan Standard Time en_US ShortStandard GMT+9 en_US DaylightSaving Japan Daylight Time en_US ShortDaylightSaving GMT+9 en_US Generic Japan Standard Time en_US ShortGeneric Japan Time ja_JP Standard 日本標準時 ja_JP ShortStandard JST ja_JP DaylightSaving 日本夏時間 ja_JP ShortDaylightSaving JDT ja_JP Generic 日本標準時 ja_JP ShortGeneric JST 上記を試したコード let timeZone = NSTimeZone.systemTimeZone() println(&amp;quot;#### abbreviation, \(timeZone.abbreviation)&amp;quot;) println(&amp;quot;#### name, \(timeZone.name)&amp;quot;) println(&amp;quot;#### description, \(timeZone.</description>
    </item>
    
    <item>
      <title>SwiftでiOSシミュレータのときだけAFNetworkActivityLoggerを使う</title>
      <link>https://www.tokoro.me/posts/swift-simulator/</link>
      <pubDate>Sat, 13 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/swift-simulator/</guid>
      <description>だいぶ小ネタ。
コード #if (arch(i386) || arch(x86_64)) &amp;amp;&amp;amp; os(iOS) AFNetworkActivityLogger.sharedLogger().level = .AFLoggerLevelDebug AFNetworkActivityLogger.sharedLogger().startLogging() #endif UIDeviceを使う方法もあるが、そちらは実際に動いたときに判別することになる。
こちらだとそもそもiPhone用のアプリからはこのコード自体省かれる形になる。
意味 arc(i386) 32bitのMac（シミュレータ）用のビルド arc(x86_64) 64bitのMac（シミュレータ）用のビルド os(iOS) ターゲットがMacじゃなくてiOS オマケ ぼくの手元では、デバッグ実行時に
#if DEBUG println(&amp;quot;DEBUG&amp;quot;) #endif で DEBUG が出力されない。普通は出力されるはず？？</description>
    </item>
    
    <item>
      <title>Swiftで部分適用（カリー化）</title>
      <link>https://www.tokoro.me/posts/swift-partial-application/</link>
      <pubDate>Wed, 30 Jul 2014 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/swift-partial-application/</guid>
      <description>Swiftオフィシャルの部分適用 まず、Swiftオフィシャルな構文として
func addTwoNumbers(a: Int)(b: Int) -&amp;gt; Int { return a + b } というように引数を１つ１つ別の括弧で囲ってfunctionを定義すると
let add1 = addTwoNumbers(1) add1(b: 2) //&amp;lt; 3 というかんじに、
まず、１つめの引数だけ部分適用（ここでは a） 部分適用したものに後から次の引数を適用（ここでは b） というのができる。
専用の書き方じゃなくてふつうのfunctionに部分適用できないの？ 使うかどうかは別としてHaskellみたいに全ての関数に部分適用できたら面白いなーと。
また、上のような専用の定義にしちゃうと addTwoNumbers(1, 2) みたいな普通の呼び方ができなくなっちゃうし。
そんなとき、 Swiftの関数の引数は、常に一つ という記事に出会い、勉強になるなーと眺めていたら、あれ？ふつうのfunctionに部分適用するための関数作れるかもなーと思い立った。
実装 https://github.com/tokorom/partial-swift
func partial&amp;lt;A, B, R&amp;gt;(function: (A, B) -&amp;gt; R, a: @auto_closure () -&amp;gt; A) -&amp;gt; (B) -&amp;gt; R { return { function(a(), $0) } } 利用サンプル func add(a: Int, b: Int) -&amp;gt; Int { return a + b } let add1 = partial(add, 1) add1(2) //&amp;lt; 3 とこんなかんじで普通の add() というfunctionに partial(add, 1) といった形で部分適用できるようになります。</description>
    </item>
    
    <item>
      <title>これがXcodeでのバージョニングの決定版になるかも</title>
      <link>https://www.tokoro.me/posts/xcode-versioning/</link>
      <pubDate>Mon, 19 May 2014 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/xcode-versioning/</guid>
      <description>概要 この記事でできるようになること 安定してInfo.plistの内容（ここではBuild番号）を変更できる ふつうにRun Scriptで編集するとタイミングによってすぐにアプリに反映されないことがあったりしたがそれが解消される Info.plistに差分がでないのでcommitのときに邪魔にならない なお、この方法を教えてくれた熊谷さんがこの方法に行き着いた経緯や所感がこちらに詳しくまとめられています。詳細や考え方などをきちんと知りたいかたは是非、熊谷さんの記事をご一読ください！
必要な設定 Preprocess Info.plist file でInfo.plistをビルド前に確定させる Run Scriptで${TEMP_DIR}/Preprocessed-Info.plistを編集する 以下、具体的な話をします。
経緯 これまで、
デバッグ用やArchive用のアプリのバージョンにだけgitのcommit番号とか最終更新日付を付ける といったことをする場合に、Run ScriptでInfo.plistを（PlistBuddyなどで）編集してやるのが常だったと思うのですが、その場合、
Compile Sourcesより前にRun Scriptを設定してもScriptで編集した内容がアプリに反映されない場合がある そのため、確実に内容を反映させるために２回ビルドを走らせたりとか&amp;hellip; 変更したInfo.plistに差分が出てソース管理上差分が出てしまう 差分を元に戻せばいいのだけど、毎回それをやるのが面倒 といった課題があったりしました（少なくともぼくの手元では）。
そういったことを踏まえて、
potatotips 第７回 で「agvtoolで超かっこよくバージョニングできますか？」という発表をしたのですが、
その後のTwitterの議論（議論というかぼくは教えてもらっただけですが&amp;hellip;）で、これぞというバージョニングの方法が生み出されました。
@tokorom ちょっと準備がややこしいですが、こういう手もあるということで https://t.co/EQYS2gVrwm こんなのどうでしょうか。正直準備がめんどうなので僕はたぶん使わないですけど。
&amp;mdash; kishikawa katsumi (@k_katsumi) May 15, 2014 @k_katsumi @tokorom おはようございます。Preprocess Info.plist という設定なんてあるんですね。感動しました。これを Yes にしたら、他の設定は触らなくても Build Phases の何より先に Info.plist がプリプロセスされて
&amp;mdash; 熊谷 友宏 (@es_kumagai) May 16, 2014 @k_katsumi @tokorom 元の Info.plist と同じ ${TEMP_DIR}/Preprocessed-Info.plist が出来上がるみたいでした。これ自体も PlistBuddy で編集できたので「Info.</description>
    </item>
    
    <item>
      <title>Objective-Cで非同期処理のテストをシンプルに書く方法</title>
      <link>https://www.tokoro.me/posts/objc-async-test/</link>
      <pubDate>Mon, 21 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/objc-async-test/</guid>
      <description>非同期処理のテストってどう書いてますか？ 標準のXCTest自体がサポートしていれば良いのですがそうではないので、非同期処理のテストを書きたい場合には、その仕組みを自作するか出来合いのライブラリを利用する必要があります。現実的な選択肢としては、
GHUnitやKiwiなど非同期処理をサポートしたテストフレームワークを利用する GHunitの非同期処理のテストの仕組みを真似て抜粋したライブラリを利用する（意外とこれが多いかも？） expectaなどのマッチャーライブラリに付属の非同期処理の仕組みを使う となるかと思います。 ただ、私が調べた時点だとどれもしっくりきませんでした。
まず、GHUnitやKiwiなどを採択している場合には良いのですが、非同期処理のテストを書くという目的だけのためにそれらのフレームワークを使うというのは冗長すぎます。
また、GHUnitの非同期処理の仕組みだけを抜き出したライブラリもありますが、TestCaseの親クラスを決まったものにしないといけない（例えばGHAsyncTestCaseを継承したTestCaseで場合のみ利用できるとか）という縛りができるのと、非同期処理を発火する前にprepareとかを呼ばないといけないのがちょっと鬱陶しい。
そういう意味だとexpectaなどのマッチャー系のライブラリの場合、親クラスも限定されないし、非同期でマッチさせたいところでその機能を使うだけなのでとてもシンプルではあります。ただ、これはこれでマッチャーで非同期処理の完了を待つ性質上、マッチするときはいいけどマッチしないときはタイムアウトまでそこで処理が待たされるという大きな課題があります。
こうしたい！ ぼくとしては理想的にはこういうライブラリを使いたいと思いました。
テストフレームワークを使っていなくても非同期処理のテストだけが実現できるシンプルなもの TestCaseの親クラスが限定されないほうがよい 余分なコードを書かずにシンプルに書きたい それを利用することでテストの実行が遅くなったりしない しかし、当初探した限りではこの条件にマッチするものが見つかりませんでした。
他言語ではどういう書き方をしている？ なお、他言語ではどういう書き方が一般的なんだろうと調べてはみたのですが、なかなかしっくりくるものが見つからず、Objective-Cでこう書けたらいいなあと思ったのは RubyMotionで使われている書き方 でした。
http://mobiletou.ch/2013/10/第五回-rubymotionでhttpや非同期処理を含むユニットテスト
some_method_with_block {|some_data| @data = some_data resume } wait_max 1.0 do @data.should.equal foo end 待たせたい場所で wait 待たせている処理が終わったら resume という本当にシンプルで分かりやすい書き方です。
ということで、Objective-Cで同じようにWait &amp;amp; Resume方式で親クラスを限定せずに使えるシンプルなライブラリを作ることにしました。
TKRGuard そして作ったのが TKRGuard です。
TKRGuard をimportするだけで先のRubyMotionとほぼ同じ書き方ができます。
// #import &amp;quot;TKRGuard.h&amp;quot; __block NSString *response = nil; [self requestGetAsyncronous:^(id res, NSError *error) { response = res; RESUME; }]; WAIT; XCTAssertEqualObjects(response, @&amp;quot;OK!</description>
    </item>
    
    <item>
      <title>Storyboardでの画面遷移をスマートにやる方法</title>
      <link>https://www.tokoro.me/posts/improve-storyboard-segue/</link>
      <pubDate>Sat, 12 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/improve-storyboard-segue/</guid>
      <description>これは potatotips第６回め で発表した この話 のまとめと後書きです。
Storyboardいいですよね！ Storyboardを使うことで、
画面と画面が疎結合になる 簡単な画面遷移ならノンコーディングで実現できてソースコードを汚さない といったメリットがあります。
Storyboard登場以前だと、次の画面に遷移させるだけでも
#import &amp;quot;NextViewController.h&amp;quot; NextViewController *nextViewController = [NextViewController new]; [self.navigationController pushViewController:nextViewController animated:YES]; といったコーディングをし、遷移元のViewControlelrは遷移先のViewControllerに依存する（importしないといけない）形でした。
しかし、Storyboardを活用することで画面遷移のために画面同士が密結合になることを避けることができるようになりました。
ただしStoryboardを使って今まで以上に悪くなるパターンがある とはいえ、Storyboardも完璧ではなく、画面遷移時に次の画面になにか値を渡したいときにはこんな実装をする必要があります。
#import &amp;quot;NextViewController.h&amp;quot; - (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender { NextViewController *nextViewController = (NextViewController *)segue.destinationViewController; nextViewController.number = @1; [self.navigationController pushViewController:nextViewController animated:YES]; } 要するにStoryboard登場以前のコードに逆戻りです。
そして、この画面遷移時に値を渡すだけのためにpublicメソッドを公開しないといけない場合もあります。
もっとひどいのは１つの画面から複数の画面に遷移させたい場合で、もはやぐちゃぐちゃになりStoryboard使ってむしろ複雑になってるとも思えてしまうほどです。
#import &amp;quot;NextViewController.h&amp;quot; #import &amp;quot;ModalViewController.h&amp;quot; - (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender { if ([@&amp;quot;Next&amp;quot; isEqualToString:segue.identifier]) { NextViewController *nextViewController = (NextViewController *)segue.destinationViewController; nextViewController.number = @1; [self.navigationController pushViewController:nextViewController animated:YES]; } else if ([@&amp;quot;Modal&amp;quot; isEqualToString:segue.</description>
    </item>
    
    <item>
      <title>Xcodeのプロジェクトファイル（pbxproj）がコンフリクトしまくるのをなんとかしたい！</title>
      <link>https://www.tokoro.me/posts/pbxproj-merge/</link>
      <pubDate>Thu, 06 Feb 2014 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/pbxproj-merge/</guid>
      <description>2014/02/09 追記
コメントのところでやり取りしているようにmergepbxの作者さんから連絡があって、この記事で書いた問題が修正されました！
今現在は merge=mergepbx がいい感じになってきているのでそっちがオススメです。
複数人でプログラミングしているとpbxprojがやたらとコンフリクトする 例えば、
Aさんが AALabel.m をプロジェクトに追加して Bさんが BBLabel.m をプロジェクトに追加して とただそれだけなのにマージのときにコンフリクトするpbxprojさん。。。
ただそれぞれファイルを追加だけのことでコンフリクトするなんて&amp;hellip;
どうにかならんもんかいとTwitterでつぶやいたところ、 @azu_re さんから有り難い教えが！
@tokorom gitはファイル別にマージ方法を指定できるので、mergepbxみたいなのをpbxprojのマージに使うようにするぐらいですかねー(まだαですが)&amp;#10;https://t.co/VxXm0fcJMb
&amp;mdash; azu (@azu_re) February 4, 2014 mergepbxを試してみる まだα版ということだがせっかくなので試してみた。基本的には
https://github.com/simonwagner/mergepbx
のREADMEどおりにインストール＆設定するだけ。
cloneして
$ ./build.py すると、同ディレクトリに mergepbx というファイルができる。それをPATHの通った場所に設置する。
2014/02/09 追記
（もしくは自分でビルドしなくても https://github.com/simonwagner/mergepbx/releases から最新版をダウンロードすることも可能）
~/.gitconfig に以下の設定を追加する
[merge &amp;quot;mergepbx&amp;quot;] name = XCode project files merger driver = mergepbx %O %A %B なお、LANG= ってところはREADMEには書かれていないのですが、ぼくの手元だと &amp;hellip; と日本語まわりでfailedになったので加えました。
2014/02/09 追記
mergepbxの最新版ではLANG=を指定しなくても問題が発生しなくなりました。
次に、.gitattributes で
*.pbxproj merge=mergepbx と pbxprojのときはマージに mergepbx を使うように設定を追加という手順です。</description>
    </item>
    
    <item>
      <title>提供するXXXViewControllerの親クラスを差し替え可能にしたい!</title>
      <link>https://www.tokoro.me/posts/super-viewcontroller-for-a-library/</link>
      <pubDate>Thu, 23 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/super-viewcontroller-for-a-library/</guid>
      <description>XXXViewControllerの親クラスを差し替えたいときありますよね？ UIKit内で言えばUITableViewControllerとかはその代表格。
外部ライブラリで言うと、Google Analytics SDKのGAITrackedViewControllerとか。
要するに、XXXViewControllerの継承して実現したい機能があるのに、既にYYYViewControllerのサブクラスなので使えないよーとなってしまうケース。
で、既存のものは置いておくとしても、自分が作るライブラリのXXXViewControllerについては、なんとかその親クラス差し替えの需要に応えられないものかなあと。
runtime使う? いちおう class_setSuperclassという関数があるのですがDeprecated&amp;hellip; なんか良い方法ないかな？と考えた結果、今のところ以下のかんじに落ち着きました。
define! 後から動的に差し替えるってのは class_setSuperclass がDeprecatedな時点で諦めるとして、だとするとコンパイル前に差し替えるしかないよねと。
例えば、こんなかんじでどうでしょう？
#ifdef XXXLIB_VIEW_CONTROLLER_IMPORT #import XXXLIB_VIEW_CONTROLLER_IMPORT #endif #ifdef XXXLIB_VIEW_CONTROLLER_SUPER_CLASS @interface TKRContainerTableViewController : XXXLIB_VIEW_CONTROLLER_SUPER_CLASS #else @interface TKRContainerTableViewController : UIViewController #endif // ... @end ふつうに使うぶんには XXXLIB_VIEW_CONTROLLER_IMPORT も XXXLIB_VIEW_CONTROLLER_SUPER_CLASS も定義されていないので普通にUIViewControllerがsuperclassになります。
もしsuperclass変えたいよ！って人は、
#define XXXLIB_VIEW_CONTROLLER_IMPORT &amp;quot;YourSuperViewController.h&amp;quot; #define XXXLIB_VIEW_CONTROLLER_SUPER_CLASS YourSuperViewController とどこかで定義してやればsuperclassがYourSuperViewControllerになるイメージです。
ひとまずこれでなんとかなりそう。
他に良い方法があればご教示を！</description>
    </item>
    
    <item>
      <title>会社でiOSアプリを扱うときのアカウント管理はこうするべきだった？</title>
      <link>https://www.tokoro.me/posts/ios-dev-accounts/</link>
      <pubDate>Tue, 05 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/ios-dev-accounts/</guid>
      <description>2013年11月18日 追記 この記事を書いた後、何人かのかたから「うちでは同じApple IDで両方とも使えているよ」というご指摘をいただき、
Member Centerのほうにアカウント追加 -&amp;gt; iTunes Connectに同じアカウント追加という順番だと「警告は出るもののかまわずContinueすれば」同じApple IDでアカウント作成可能 iTunes Connectにアカウント追加 -&amp;gt; Member Centerに同じ追加という順番だと「複雑な手順にはなるものの適切な手順を通せば」同じApple IDでアカウント作成可能 失礼しました。
追加情報などあれば是非おねがいします！
概要 私はiOSアプリの開発を3年以上やっていますが、恥ずかしながら会社でこのためのアカウントを管理/運用する方法をきちんと把握できていませんでした。
というのも個人で開発するぶんにはそんな管理は必要なかったですし、これまで会社でアプリ開発するときも限られた数人だけが担当していたのでアカウントの管理とか必要がなかったのです（というのが言い訳です）。
おそらく、企業でiOSアプリ開発をしている人にとっては普通のことなんでしょうけど、私は今回はじめて知った部分がいくつかあったのでまとめさせていただきます。
どこかで困っているどなたかに参考になれば良いなというのと、もっとこうしたほうが良いというご意見をいただくのが目的です。
iOS Dev Center の構成 まず、iOS Dev Centerで今回説明する部分は以下のような構成になっています。
大きくは、
iOS Developer Program Member Center iTunes Connect に分かれます。
メンバーを追加する方法が２つある？？ 今回、私が混乱してしまった部分がここでした。
iOSアプリ開発/公開のために必要なアカウントは、
Member CenterのPeople iTunes ConnectのManage Users の2カ所で管理されています。
また、この２つのアカウントはそれぞれ別々の用途になります。
個人開発のアカウントや、会社の代表アカウントを使う際には１つのアカウントでこの２つの役割を同時に担ってくれるため、この２つが違うということを気にしなくても良かったのです。
Member CenterのPeopleに追加すべきユーザは？ 主にiOS Developer Programのページを使うプログラマです。
Certificate（証明書）の発行 Device（開発機）の登録 App ID の登録 Provisioning Profile の発行 が必要なユーザがこれに該当します。
iTunes ConnectのManage Usersに追加すべきユーザは？ リリース担当、経理担当、法務担当などです。
アプリのリリースと管理 売り上げやダウンロード数の確認 銀行、税金情報などの管理 が必要なユーザがこれに該当します。</description>
    </item>
    
    <item>
      <title>Objective-Cでカリー化とか部分適用してみる</title>
      <link>https://www.tokoro.me/posts/objective-c-haskell/</link>
      <pubDate>Mon, 04 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/objective-c-haskell/</guid>
      <description>導入 会社でHaskell勉強会に参加して、カリー化とか部分適用のパートの輪読当番になったのだが、正直、輪読時点でもそれがなんなのかよくわかっていませんでした。 しかし、勉強会で参加者のみなさまに教えてもらった結果、カリー化とかがやっと理解できました！
ということで嬉しくなって先日寝るときに布団の中で「Objective-Cでもできるかなー」と脳内コーディングしてみた結果を実装してみました。
もう他の人がやってるかもとか、こんなん実装しても実際のところ使わないよねとか、そんなことはまったく気にせずです。
実際やってみたソースコードは こちら に置いてあります。
ひとまずのゴール カリー化して部分適用ができる状態までということで、Haskellのmapが実現できるところまでを目標にしました。
map (+3) [1, 2, 3] これです。
Objective-Cでは当然、空白区切りで引数を渡していくような構文はないわけなので、関数ポインタ的なやつを使って、
map (+3) ([1, 2, 3]) みたいな形で()で区切り、関数の実行結果として取得した関数ポインタ（実際に関数が返すのはBlock）を使って次の引数を渡す（要するにカリー化）することでこれを実現することにしました。
しかし、Objective-Cには演算子を()で囲ってセクション化するとかないし、リストのリテラルも違うので、やるとしたらこうなります。
map (OP(&#39;+&#39;) (@3)) (@[@1, @2, @3]) セクションに関しては、演算子を関数化するマクロを作り、その関数に引数を１つ部分適用するイメージとします。
ということで、Objective-Cで上のmapが実現できたらはじめのゴールとしては十分かなと思いました。
カリー化の実現方法 実際にカリー化した関数の実装はこんなかんじになりました。これは２つの引数を加算して返す add の実装です。
#define add [ObjcHaskell hsAdd] + (curryingBlock)hsAdd { CURRYING2( x, y, return @([x intValue] + [y intValue]); ); } CURRYING2という変なマクロを使ってObjective-Cらしからぬ見た目になってますが、マクロを展開すると実際はこうなります。
#define add [ObjcHaskell hsAdd] + (curryingBlock)hsAdd { return (curryingBlock)^(id x) { return (unaryBlock)^(id y) { return @([x intValue] + [y intValue]); } }: } Blockを返すBlockを返す関数というかんじになってます。 外側のBlockはxという引数を取り、中側のBlockを返す。 中側のBlockはyという引数を取り、外側のBlockでキャプチャされたxと自分でキャプチャしたyを加算した結果を返す。</description>
    </item>
    
    <item>
      <title>iOS 7はもっさりか？比較検証してみた</title>
      <link>https://www.tokoro.me/posts/ios7-design/</link>
      <pubDate>Mon, 23 Sep 2013 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/ios7-design/</guid>
      <description>今回の記事はUIデザイナの Morino氏 からの寄稿です。
iOS 7が正式リリースされました。既にアップデートを行って実際に試されている方も多いと思いますが、今回はUIに大幅な変更が加えられたために、まだ操作に戸惑いのある方もいるのではないでしょうか。
特にiOS 7にしてから重く感じる、もっさりしているという意見もけっこう多いようです。iOS 7をしばらくいじってからiOS 6の端末を触ると、たしかにiOS 6の方がきびきび動いているように感じます。 今回は半透明やぼかし、視差効果などの画像エフェクトをふんだんに使用しているために画像処理の負荷が高いことも確かでしょう。しかし、全てが端末の性能のせいというわけでもないことを、今回はご紹介したいと思います。
頻繁に操作を行う以下の4つのシーンについて、ちょっとした比較検証を行いました。
ロック解除してから、ホーム画面のアイコンが全て出現するまでの時間 アプリアイコンをタップしてから開くまでの時間 フォルダをタップしてから開くまでの時間 ホームボタンをダブルクリックしてから、マルチタスク画面を開くまでの時間 iOS 6とiOS 7それぞれの検証結果は、以下の通りです。
※iOSシミュレータで検証を行ったため、実機とは多少違いがある点はご容赦ください。また、時間の長さも30fpsの動画で1フレームずつ進めながら自分でカウントした数値です。
##ロック解除してから、ホーム画面のアイコンが全て出現するまでの時間 iOS 6（左） : 0.5s iOS 7（右） : 1.0s ##アプリアイコンをタップしてから開くまでの時間 iOS 6（左） : 0.4s iOS 7（右） : 0.7s ##フォルダをタップしてから開くまでの時間 iOS 6（左） : 0.3s iOS 7（右） : 0.6s ##ホームボタンをダブルクリックしてから、マルチタスク画面を開くまでの時間 iOS 6（左） : 0.3s iOS 7（右） : 0.6s 検証を行った全てのシーンにおいて、iOS 7では時間が倍近くかかっていることがお分かりになると思います。 ほんのコンマ数秒の世界ですが、このわずかな違いだけでもっさりしていると感じてしまうものなんですね。
ではアップルはなぜあえて動きを長くする必要があったのでしょうか？
iOS 7のUIからフラットデザインが採用されたのはご存知の通りです。それはユーザーリテラシーの向上と同時に、コンテンツが最も重要で、UIはあくまでコンテンツの邪魔をしない存在であるべき、という思想から来ています。 ところがフラットデザインは、UIとしては得てして分かりにくくなってしまいがちな表現手法なんです。アップルはその分かりにくさを補うために独自の工夫を色々盛り込みましたが、その一つに操作結果をはっきりと分かりやすく見せるためのトランジション効果があります。これらのトランジションは動きが速すぎて何が起きたのか分からないのでは意味をなさないため、ちょうどよい速度に調整した結果でもあるでしょう。
もちろん、UIの機能そのものを改善して画面全体を使うようにしたために、単に動きが大きくなって時間を要するものもありますね。マルチタスク画面やSafariの画面選択などはこれに当たります。 また遅めに調整された他の画面に合わせるために、単純にスピードを緩めたという場面も中にはあるでしょう。
いかがでしょうか。上記に示した理由が全てではないとは思いますが、コンテンツを見せること・扱いやすくすることを最優先とした今回の新UIにおいて、そのトレードオフの結果としての動きがゆったりめのトランジションであり、もっさり感じる主な理由であると私は考えています。UIの進化に伴って、必然的に生まれたテンポなのではないでしょうか。今後もフラットUIにユーザーが慣れてきてリテラシーも向上してくれば、より機敏な表現も登場してくると思います。</description>
    </item>
    
    <item>
      <title>iOSのライブラリだってTravis CIとかCoverallsとか使うべき</title>
      <link>https://www.tokoro.me/posts/objc-travis-coveralls/</link>
      <pubDate>Tue, 09 Jul 2013 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/objc-travis-coveralls/</guid>
      <description>今日はGithubに公開したiOS用のライブラリを Travis CI と Coveralls に対応した手順を紹介したいと思います。
なお、実際にこれらを適用して運用しているリポジトリのサンプルは、
https://github.com/tokorom/BlockInjection
になります。
前提条件 GitHubを使っていること GitHubでなんらかiOS/Mac用のライブラリを公開していること Travis CI https://travis-ci.org/
目的 公開しているライブラリの最新コードがきちんとビルドが通るものか、テストが通る状態かを明示できます。
iOS用のCI環境を用意するのは通常すごく敷居が高い（物理的にMacが必要）のですが、Travis CIはiOS/Mac用のライブラリのCIを無料で請け負ってくれるかなり太っ腹なサービスです。
事前準備 Travis CIのアカウントを作っておく(GitHubのアカウントで） Travis CI上で該当のリポジトリをONにする Travis CI に行って、このスクリーンショットのように該当リポジトリを ON にするだけです。簡単！
Makefile を用意する（必須ではない） 必須ではないですが、Makefileを作っておくほうがいろいろとメリットある気がします。
自分の場合は、
PROJECT = BlockInjectionTest/BlockInjectionTest.xcodeproj TEST_TARGET = Tests clean: xcodebuild \ -project $(PROJECT) \ clean test: xcodebuild \ -project $(PROJECT) \ -target $(TEST_TARGET) \ -sdk iphonesimulator \ -configuration Debug \ TEST_AFTER_BUILD=YES \ TEST_HOST= こんなかんじで、 make test とすると xcodebuild で Tests がビルドされるようにしています。 TEST_AFTER_BUILD=YES と TEST_HOST= は重要です。</description>
    </item>
    
    <item>
      <title>【アプリ開発のお手本に】iOS 7の設計においてアップルが大切にした4つのポイント</title>
      <link>https://www.tokoro.me/posts/ios7-ui-design/</link>
      <pubDate>Mon, 17 Jun 2013 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/ios7-ui-design/</guid>
      <description>今回の記事はUIデザイナの Morino氏 からの寄稿です 前回 はiOS 7紹介ビデオの中のジョナサン・アイブ氏のパートをご紹介しました。
今回は、その中でも特に重要と感じたいくつかのフレーズをピックアップして深堀りしてみたいと思います。
&amp;ldquo;True simplicity&amp;rdquo; iOS 7から話題の&amp;quot;フラットデザイン&amp;quot;が採用されて、画面デザインは大分シンプルな外観になりました。
使う色の数は限定され、簡単明瞭なラインやシルエットがほとんどのデザインを占めています。
iOS 6まで採用されていたSkeuomorphism（装飾的・リアルな外観）は排除され、立体的で質感を感じるデザインから、平面的で形やテキストの意味性をストレートに伝えるデザインに変わりました。
ただ、&amp;ldquo;Simplicity&amp;quot;という言葉は、単に外観を表すものとして使われているわけではありません。
「複雑さに秩序をもたらす」という台詞にもあるように、これは見た目だけではなく、見せたい情報の構造設計から、情報やコントロールをレイアウトした画面の設計まで、目に見える範囲の全ての要素を指していることが分かります。
実際に設計を行う段階では、一つ一つの画面の中だけで閉じて検討をするのではなくて、アプリ全体の画面の流れを考慮に入れながら三次元的に情報を整理し、「秩序」について考えなくてはいけないでしょう。
なるべくユーザーにとって理解しやすい情報の見せ方・順番を考え、ユーザーが迷わないインタフェースの動線を考える必要があります。
全ての情報が詰め込まれた一つの画面よりも、10の画面に整理して分けられたインタフェースのほうが好まれることも多いと思います。
これらはInformation Architectとして大変重要な要素でもありますが、ひとまず画面の外観に話を戻します。
アップルは今回、外観的な&amp;quot;Simplicity&amp;quot;を表現するに当たって、ただ画面の要素をシンプルなデザインにしただけではなく、他にも様々な工夫を行っています。
画面をシンプルにした一方で、分かりやすさや操作性、ユーザーエクスペリエンスを向上させるために色々な仕掛けやルールを用意しているのです。
これらは、私たちアプリ開発者も積極的に参考にしたり真似をしていくべき考え方でもあります。
では、アップルの&amp;quot;Simplicity&amp;quot;を構成する要素にはどのようなものがあるでしょうか。
1. &amp;ldquo;refining the typography&amp;rdquo; タイポグラフィー（文字組み）が読みやすく、認識しやすいようにアップデートされました。
英文フォントにはこれまでよりも細いフォントタイプが追加され、非常に繊細ながらも読みやすく美しい様を演出しています。
一方で強調すべきウェイトの重い（太い）文字列との差がよりはっきり認識できるようになり、コンテンツとしての可読性も向上したと言えます。
ナビゲーションバーのボタンも、アイコンが廃され、テキストのみで簡潔に機能を伝えるものが多いようです。
タイポの美しさを最大限に引き出したいという意図だと思われますが、画面のシンプルさを維持するためにボタンの境界線も排除されています。
その代わりに、押せるボタンであることを明確に示すために、通常テキストとははっきりと違う色を割り当てて、アプリ全体で一貫して使われています。
その色＝ボタンであることをユーザーが一度学習すれば、操作に問題がでないことを前提としていますが、ボタン配置には大きな変更はないのでiOS 6からのユーザーにとっては順応も容易いでしょう。
これらのボタンのテキスト色はアプリによっても様々なようですが、やはり通常テキストとの比較によって違いが明白であることを基本としています。
私たちが同様の思想に基づいてアプリ開発を行う場合に気をつけなくてはいけないのは、色を多用しないことです。 通常テキストとボタンのテキストの2色だけを使うのが安全です。
複数のテキスト色が混ざり合ったインタフェースになってしまうと、どれがボタンなのか判断がつかなくなってしまいます。
もう一つ懸念点があるとすれば、日本語のタイポグラフィーにおいても、英文と同じ可読性・美しさを確保できるかということです。
場合によっては、余白を多めに取るなどの工夫を行ったほうがよいことも多そうです。
2. &amp;ldquo;redesigning all the icons&amp;rdquo; 標準アプリのアイコンは全て共通の新しいグリッドシステムに基づいてデザインし直されています。
このグリッドシステムに従うことで、アイコンごとのグラフィックのバランスに統一感・一貫性を持たせています。
もちろん従う必要はありませんが、ホーム画面において標準アプリアイコンとの一体感を重視するのであれば、参考にするとよいでしょう。
既に一部のデザイナーからリリースされているPhotoshopやIllustratorのグリッドシステムのテンプレートを入手することができます。
3. &amp;ldquo;use of translucency&amp;rdquo; 地味ながらも美しく、活用の余地が大きい機能追加だと思います。
画面上部から引き下げるNotification Center、画面下部から引き上げるControl Center、キーボードやダイアログなど、様々なアイテムがすりガラス風の半透明な板で表現され、背景がぼんやりとボケて見えるだけですが、その存在を感じ取ることで「後ろに何かがある」ことを認識できるようになりました。
ただ画面をフラットに、シンプルにしただけではなく、このようなエフェクトを活用することで画面上の情報量を増やすことなく情報・状況の認知性の向上と、三次元的な重なり合いによる画面の深み・面白みを表現することに成功しています。
例えばメッセージアプリにおいては、送信した内容がヒュッと画面下部から現れてタイムラインに飛び込んでくる様子を感じることができ、ボタンを押して成功したというフィードバックを得ると同時に、メッセージを送るという行為の楽しさを体感することができます。
4. &amp;ldquo;parallax to create a whole new experience of depth.</description>
    </item>
    
    <item>
      <title>Objective-Cのコードを削れるだけ削る7のTips</title>
      <link>https://www.tokoro.me/posts/objc-reduce/</link>
      <pubDate>Sat, 15 Jun 2013 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/objc-reduce/</guid>
      <description>既存記事のまとめのため新しい要素があるわけではないのですが、Appleから発表されたXcode 5が正式にリリースされる前の復習ということで。
Tipsを適用する前のコード #pragma mark - Private Category @interface Sample () @property (strong) NSNumber* i; @property (strong) NSNumber* c; @property (strong) NSNumber* f; @property (strong) NSArray* array; @property (strong) NSDictionary* dictionary; @property (strong) Sample* child; @property (strong) UIColor* color; @property (assign) NSUInteger index; @property (assign) CGRect rect; - (void)privateMethod1; - (void)privateMethod2; - (void)privateMethod3; @end #pragma mark - Main Implementation @implementation Sample @synthesize i = i_; @synthesize c = c_; @synthesize f = f_; @synthesize array = array_; @synthesize dictionary = dictionary_; @synthesize child = child_; @synthesize color = color_; @synthesize index = index_; @synthesize rect = rect_; - (void)privateMethod1 { [self privateMethod2]; [self privateMethod3]; } - (void)privateMethod2 { self.</description>
    </item>
    
    <item>
      <title>iOS 7 Video の内容の書き起こしと日本語訳（寄稿:UIデザイナMorino氏)</title>
      <link>https://www.tokoro.me/posts/ios7-video/</link>
      <pubDate>Thu, 13 Jun 2013 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/ios7-video/</guid>
      <description>今回の記事はUIデザイナの Morino@WWDC2013参加中 に寄稿いただきました！ Appleの公式サイトに iOS 7 を紹介するビデオが公開されましたね。
http://www.apple.com/ios/ios7/
特に前半の4分間でジョナサン・アイブ氏により語られているiOS 7の説明部分に、今回の大きなデザイン変更の様々な要点が含まれており、これからのアプリ設計のあるべき方向性が示唆されています。
これらをよく理解しておくことが非常に重要だと感じていますので、自分自身の復習のためとみなさんへの展開の意味で、書き起こし＆和訳を行いました。
デザイナのみならずアプリ開発者の皆様にも有用かと思いますので、ぜひご参照ください。
iOS 7 Video - 書き起こし &amp;amp; 和訳 ※ 画像はすべて iOS 7 Video の中からの抜粋です
We have always thought of design as being so much more than just the way something looks.
私たちは常にデザインを、ただ外見がどう見えるかよりも遥かに大きな存在として捉えてきました。
It’s the whole thing the way something actually works on so many different levels.
デザインは、様々なレベルにおいて何がどう作用するかという、その全てを指すのです。
Ultimately of course, design defines so much of our experience.
最終的には、デザインは私たちが体験する物事のあまりに多くを定めるのです。
I think there is a profound and enduring beauty in simplicity, in clarity, in efficiency.</description>
    </item>
    
    <item>
      <title>Xcode 5: TDD/CIまわりに強力なアップデート(Appleがサイトで公開している範囲内で)</title>
      <link>https://www.tokoro.me/posts/xcode5-preview/</link>
      <pubDate>Wed, 12 Jun 2013 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/xcode5-preview/</guid>
      <description>tokorom@WWDC2013参加中です。
WWDC2013で膨大なアップデートを学習中でしゃべりたいことが盛りだくさんなんですが、NDAのため我慢の日々。
で、キーノートの範囲の話は既に各所で情報が出ているわけですが、キーノートに出ていない項でも、Appleが非ログインで参照できるサイトで既に公表しているものがいくつかありました。
概要レベルでありますが、なかでも TDD とか CI まわりでiOSアプリ開発者にとって嬉しい情報がありましたので報告させていただきます。
あくまでもAppleのサイトで公表されている範囲内のことしか書けませんのであしからず。
ついにXcodeから任意のテストだけを簡単に実行できるようになる ついに、ついに&amp;hellip;というかやっとかという話。
Xcode 5 で Test Navigator というやつが加わり、テスト駆動での開発を助けてくれますとのこと。具体的に、 シングルクリックで特定の１つのテスト、もしくは選択した複数のテストを実行できる という記載があります。
また、 テストとソースコードを side by side で自動的に配置する という記載もあります。
これでObjective-Cな人たちもまともにTDDできる日がやってくるかもしれないですね。
CIの機能も入ります / その名は &amp;ldquo;Bots&amp;rdquo; 公表されている概要だけ並べてみると、
２、３回のクリックで新しいbotを作ることができる ネットワーク上のどのMacでも直ちにbotをスタートできる 別のMacでCIを回している間も、自分のMacでビルド結果やテストの結果を確認できる とのこと。
Jenkinsで良い気もしますが、Xcodeから簡単にジョブを作成できるのは魅力的です。もしかするとBotsとJenkinsを連携させて使うという可能性もありそうです。
その他 もっとしゃべりたいことがたくさんあるのですが、正式に公表されたタイミングでまた紹介させていただければと思います。。。
参照元 What&amp;rsquo;s New in Xcode 5</description>
    </item>
    
    <item>
      <title>UIAlertViewよりもおとなしいメッセージダイアログを利用する</title>
      <link>https://www.tokoro.me/posts/ssgentlealertview/</link>
      <pubDate>Mon, 27 May 2013 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/ssgentlealertview/</guid>
      <description>UIAlertViewは警告目的のダイアログ そもそもUIAlertViewはエンドユーザになんらかの警告をするときに利用するもので、iOSヒューマンインターフェースガイドラインにも、
一般にアラートは、次のような場合には不要です。 * なんらかの情報、特にアプリケーションの標準機能に関する情報を目に付かせるためだけの場合。 代わりに、アプリケーションのスタイルに調和し、目を引く情報表示の方法を設計すべきです。 と記載されています。
その一方で、UIAlertViewは簡単に利用でき、なんらかの情報を表示するのにどうしても使いたくなってしまいます。
それならばUIAlertViewの外観を変えて使えば、というのも考えられますが、ところがどっこいUIAlertViewはAppearanceの変更を一切サポートしていません。
警告目的のアラートダイアログの外観がアプリによって変更されると、エンドユーザからすればそれがなんらかの警告であると認知しづらくなってしまうからだと思われます（アラートダイアログについては全アプリで共通であるべきという思想）。
警告目的ではない普通のメッセージダイアログ それでは、警告目的でない汎用的に使える普通のメッセージダイアログがあったほうが良いねという話になり、作ってみました。
https://github.com/tokorom/SSGentleAlertView
このSSGentleAlertViewは、
UIAlertViewと同じコードで利用できる UIAlertViewとは違い、外観を変更できる デフォルトではUIAlertViewよりもおとなしめなダイアログ表示になる という３点に留意して作っています。
画像パーツやカラーリングなどはUIデザイナの Atsushi Morino さんに作ってもらってるのでちゃんとしてます。
外観 自分でカスタマイズしない場合でも、次の3種のスタイルが選べます。
Default Black Native サンプルコード UIAlertViewを使うときのコードのUIAlertViewの部分をSSGentleAlertViewに変更するだけです。
// #import &amp;quot;SSGentleAlertView.h&amp;quot; SSGentleAlertView* alert = [SSGentleAlertView new]; alert.delegate = self; alert.title = @&amp;quot;SSGentleAlertView&amp;quot;; alert.message = @&amp;quot;This is GentleAlertView!\nUIAlertView is too strong to use for ordinary messages.&amp;quot;; [alert addButtonWithTitle:@&amp;quot;Cancel&amp;quot;]; [alert addButtonWithTitle:@&amp;quot;OK&amp;quot;]; alert.cancelButtonIndex = 0; [alert show]; なお、インスタンスを作る際に[[SSGentleAlertView alloc] initWithStyle:SSGentleAlertViewStyleBlack] のようにすることで、３種のスタイルを選択できます。
外観の変更 また、外観を変更することも簡単にできます。例えば、</description>
    </item>
    
    <item>
      <title>UIKitで使われている画像パーツをまとめて取得する</title>
      <link>https://www.tokoro.me/posts/uikit-images/</link>
      <pubDate>Thu, 23 May 2013 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/uikit-images/</guid>
      <description>UIKitで使われている画像はどこにある？ 例えば、UIAlertViewのアラートの画像ってどういう構成になってる？とかUISegmentedControlのAppearance変えたいんだけど当てはめる画像はどう作る？などというときにUIKitが標準で使っている画像パーツを参照できると便利です。
プログラマというか特にはデザイナさんにとって有用だと思います。
その画像パーツですが、Xcode（iOSシミュレータ）の中に入っているのでそこから抜くのが手っ取り早いです。
具体的には（これはiOS6.1の場合）、
/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator6.1.sdk/System/Library/Frameworks/UIKit.framework/Shared@2x.artwork が画像パーツを含むファイルになります。
他にも、同じディレクトリに
Shared.artwork Shared@2x~ipad.artwork Shared@2x~iphone.artwork Shared~ipad.artwork Shared~iphone.artwork がありますので取りたいものに応じてお好みで。
ひとまず、
cp /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator6.1.sdk/System/Library/Frameworks/UIKit.framework/Shared@2x.artwork ~/Desktop/ などでこのファイルをデスクトップにでもコピーしておきましょう。
artworkから画像ファイルを抽出 で、artworkから肝心の画像ファイルを抽出するのに、 iOS-artwork というやつを使わせてもらいます。
まずは、これを
git clone git://github.com/davepeck/iOS-artwork.git などでダウンロードします。
ただ、これを使うにはPythonとPILというライブラリが必要です。
たぶんPythonは元から入っていると思うので、PILのほうをbrewなどでインストールします。
brew install pil インストールし終わったら
mkdir ~/Desktop/UIKitParts ./iOS-artwork.py export -a ~/Desktop/Shared@2x.artwork -d ~/Desktop/UIKitParts と先ほどダウンロードしたiOS-artworkを実行するわけですが、おそらくここで、
Traceback (most recent call last): File &amp;quot;./iOS-artwork.py&amp;quot;, line 32, in &amp;lt;module&amp;gt; import PIL ImportError: No module named PIL と怒られると思います。インストールしたはずのPILが見つからないとのこと。そのため、
export PYTHONPATH=/usr/local/Cellar/pil/1.1.7/lib/python2.7/site-packages としてPILの場所をPythonに教えてあげます（brew以外でインストールした人はディレクトリをその場所に置き換えてください）。
気を取り直して、
./iOS-artwork.py export -a ~/Desktop/Shared@2x.artwork -d ~/Desktop/UIKitParts を実行すれば、デスクトップのUIKitPartsというディレクトリにUIKitの画像一式がもりもりと出力されていくはずです！</description>
    </item>
    
    <item>
      <title>BlockInjectionをバージョンアップしました</title>
      <link>https://www.tokoro.me/posts/blockinjection2/</link>
      <pubDate>Mon, 01 Apr 2013 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/blockinjection2/</guid>
      <description>BlockInjectionとはなんぞや Objective-Cの特定のメソッドの前後に処理を追加できるライブラリです。
クラスの外側からアスペクト指向的に振る舞いを追加できるのが特徴です。
https://github.com/tokorom/BlockInjection で公開しています。
バージョンアップ内容 前記事 からのバージョンアップ内容は以下です。
リファクタリングしてメソッド名が一式変更になりました（これまでのものはDeprecatedですがまだ使えます） クラスメソッドにも対応しました 複数のクラスやメソッドを一度に追加できるようになりました 正規表現で指定できるようになりました(※1) 注入したBlockの中で注入先のメソッド名を取得できるようになりました(※2) オマケで単純なメソッド実装置き換え機能も追加しました UIViewの勝手に呼ばれているsetterでまとめて全てログ出力させる 既存のクラスライブラリの挙動がいまいち分からなくて、いったいどんなタイミングでなにが変更されているんだろうと気になったことはないでしょうか。
例えば、上記バージョンアップの中の ※1 と ※2 の利用サンプルとして UIViewのsetter全でまとめてログ出力をする ようにしてみます。
BlockInjectionを使えば、たった3行のコードでこれが実現できます。
[BILib injectToClassWithNameRegex:BIRegex(@&amp;quot;^UIView$&amp;quot;) methodNameRegex:BIRegex(@&amp;quot;^set.*$&amp;quot;) preprocess:^{ NSLog(@&amp;quot;%@&amp;quot;, [BILib prettyFunction]); }]; これを実行すると、UIViewを作っただけで勝手に呼ばれたsetter群が
-[UIView setContentScaleFactor:] -[UIView setFrame:] -[UIView setNeedsDisplay] のように全てログ出力されます。
+ (BOOL)injectToClassWithNameRegex:(NSRegularExpression*)classNameRegex methodNameRegex:(NSRegularExpression*)methodNameRegex preprocess:(id)preprocess; が正規表現でクラス名とメソッド名を指定して処理を注入するためのメソッドです。
正規表現にマッチする全てのクラス/メソッドの直前に指定したBlockを埋め込みます。
また、[BILib prettyFunction] は注入先のメソッド名を__PRETTY_FUNCTION__と同じ形式で取得できる便利機能です。
ちなみに、BIRegexというのはただNSRegularExpressionを簡易的に作るための関数ですので、↑のコードは以下と同義です。
NSError* error = nil; NSRegularExpression* classNameRegex = [NSRegularExpression regularExpressionWithPattern:@&amp;quot;^UIView$&amp;quot; options:0 error:&amp;amp;error]; NSRegularExpression* methodNameRegex = [NSRegularExpression regularExpressionWithPattern:@&amp;quot;^set.*$&amp;quot; options:0 error:&amp;amp;error]; [BILib injectToClassWithNameRegex:classNameRegex methodNameRegex:methodNameRegex preprocess:^{ NSLog(@&amp;quot;%@&amp;quot;, [BILib prettyFunction]); }]; ※2013/04/05追記: ちなみに 特定Prefixのメソッド全てにまとめて振るまいを追加する というのは @7gano さんのアイデアです。</description>
    </item>
    
    <item>
      <title>BlockInjectionで元のソースコードを汚さないで振る舞い追加</title>
      <link>https://www.tokoro.me/posts/block-injection/</link>
      <pubDate>Thu, 07 Mar 2013 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/block-injection/</guid>
      <description>例えばこんなコードに違和感はありませんか？ 自分の場合よくあることなのですが、例えばiOSアプリを開発していて、Google Analytics のトラッキングのためのコードを加えるとき、
- (IBAction)sendButtonDidPush:(id)sender { // トラッキングのためのコード [tracker sendEventWithCategory:@&amp;quot;uiAction&amp;quot; withAction:@&amp;quot;sendButtonDidPush&amp;quot; withLabel:nil withValue:0]; // ... // 以降、送信ボタンを押したときの処理 // ... } こんなかんじにボタンが押されたときの処理のところにトラッキングのためのコードを埋め込んだりすると思います。
これはこれで問題はないのですが、プログラムのあちらこちらにトラッキングのためのコードを埋め込んで、本来の処理のコードを汚してしまっているのに違和感がありました。
どうにかしてトラッキングのためのコードを外出しに（また、理想的にはどこかにひとまとめに）できないものでしょうか？
いわゆるアスペクト指向的なかんじで。
そんなときに BlockInjection ということで本題に入りますが、それを解決するために BlockInjection というライブラリを作りました。
古くは AspectCocoa だったりいくつかそれっぽいのはあったのですが、いずれも古い、大きすぎるなどの理由で適切なものが見つからなかったため、この目的に特化したライトなやつとして作っています。
例えば、上記のコードの場合、こんなかんじで外側から処理を埋め込めます。
#import &amp;quot;BILib.h&amp;quot; [BILib injectToClass:[XXXViewController class] selector:@selector(sendButtonDidPush:) preprocess:^{ // sendButtonDidPush: が実行される直前にこのコードが実行されます [tracker sendEventWithCategory:@&amp;quot;uiAction&amp;quot; withAction:@&amp;quot;sendButtonDidPush&amp;quot; withLabel:nil withValue:0]; }]; これで元のソースコードをいじらずにトラッキングの処理を埋め込むことができるようになりました！
以下、Q&amp;amp;A方式でライブラリの機能を簡単に紹介させていただきます。
対象となるクラスをimportしないと使えないとかダサくない？ 確かに、トラッキングのコードをまとめたいときなど、各クラスに処理を埋め込むためにimportがずらっっと並ぶのも不恰好です。
そんなときのために、クラス名もメソッド名も文字列で指定できるインターフェスが用意されています。
[BILib injectToClassWithName:@&amp;quot;XXXViewController&amp;quot; methodName:@&amp;quot;sendButtonDidPush:&amp;quot; preprocess:^{ // 埋め込みたい処理 }]; 対象となるクラスインスタンスのpropertyを参照できないと意味ないよ 確かに、ただ処理を埋め込むだけでなく、対象となるインスタンスによって処理が変わるようなことは多々ありますよね。
そんなときは埋め込むブロックの第1引数に対象となるインスタンスが渡ってくるのでそれを利用できます。
[BILib injectToClass:[XXXViewController class] selector:@selector(sendButtonDidPush:) preprocess:^(XXXViewController* vc){ // ここでXXXViewControllerの中身が好きなように参照可能 NSLog(@&amp;quot;State: %d&amp;quot;, vc.</description>
    </item>
    
    <item>
      <title>tmuxでC-t C-tでのサイクルをより便利にする : 同じキーでpaneでもwindowでも行き来できるようにしてみた</title>
      <link>https://www.tokoro.me/posts/tmux-toggle/</link>
      <pubDate>Thu, 17 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/tmux-toggle/</guid>
      <description>** ※tmuxのprefixキーが C-t 以外のかたはそのキーに読み替えをお願いします **
導入 近頃の開発環境 : Mosh、z、tmux、Emacs、Perl について を読んで自分もC-t C-tでtmuxのペイン（pane）を行ったり来たりというのを真似してみた。
設定は以下のとおり。
.tmux.conf bind C-t last-pane これでpaneが複数ある場合には C-t を連打するだけで２つのpaneを行ったり来たりでき確かに便利。
ただ、じつはこの真似をする前には C-t C-t には last-window を割り当てており、paneを使っていないケースではそれはそれで便利だった。
例えば、設定を変えたことによって、paneなしで２つのwindowで作業しているときに C-t C-t で２つのwindow行き来しようと思ったらエラーとなりけっこうストレスがあったりした（慣れれば大丈夫なんでしょうけど）。
改善 ということで、
paneがあれば last-pane paneがなければ last-window ついでにwindowさえもなければ新しいwindowを作って移動 というのができれば最強なんじゃないかと思った。
そんなんできるんかいな？と思ったけどごくごく普通にできた。
設定は以下のとおり。
.tmux.conf bind C-t run &amp;quot;tmux last-pane || tmux last-window || tmux new-window&amp;quot; runはshを叩くことを意味し、last-paneとlast-windowとnew-windowを||で連結させている。
これで、last-paneから順番に試していき、成功したところで終わるという挙動になる。
便利便利！</description>
    </item>
    
    <item>
      <title>VimでiOSのリファレンスを直接参照したい → CtrlPの拡張でできるようになりました</title>
      <link>https://www.tokoro.me/posts/ctrlp-docset/</link>
      <pubDate>Tue, 15 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/ctrlp-docset/</guid>
      <description>Vimでリファレンス読む必要ありますか？ 正直微妙なところでしょうか。
自分の場合、 Dash があればVimで直接にリファレンスAPIドキュメントとか)を見れなくてもそんなには困ってないです。
ただ、せっかく前の記事でVimでObjective-Cのコード補完をできるようにしたので、リファレンスもVimで参照できるようにしてみたいと思います。
Vimでさらっと検索してリファレンスから関数をコピー そのままプログラミングにペースト というのをキーボードから手を離さずに手早くできるというメリットはありそうです。
※ ただ、がっつりドキュメント読むときはやはりDashとか使ったほうが良いと思います
Docsetを検索するCtrlPのエクステンションを作りました ctrlp-docset というpluginを作りました。
オフィシャルのiOSのドキュメント(iOS 6.0 Library)は Docset 形式になっているので、そのDocsetをVimから参照するイメージです。
なのでiOS専用というわけではなく、Docsetならなんでも参照可能です。
vim-refと迷いましたが、CtrlP を使ってみたかったのでCtrlPのエクステンションとして作成しました。
CtrlPについては、
意外と知られていない便利なvimプラグイン「ctrlp.vim」 Vimプラグインの拡張機能プラグインを作ってVimをさらに使いやすくしよう あたりがわかりやすかったです。
インストールして動かすと、
といったかんじで、クラスやメソッドをインクリメンタル検索できるようになります。
参照したい項目を選択するとデフォルトだとブラウザでドキュメントが参照できます。
自分はVim内で完結したいので w3m.vim を使ってVim内で表示するように設定しました。
インストール まずはDocsetがインストールされているか確認 これがないとはじまりません。
あるかどうか心配なかたは、Xcodeを起動し、 Preferences&amp;hellip; の Downloads を確認してみてください。
ここの Documentation タブのほうで iOS 6.0 Library かそれに相当するものが Installed とインストール済みになっていれば問題ありません。
なければここからインストールをしてみてください。
なお、ここでインストールしたDocsetは、たぶん
~/Library/Developer/Shared/Documentation/DocSets/com.apple.adc.documentation.AppleiOS6.0.iOSLibrary.docset に配置されると思います。
CtrlP と ctrlp-docset をインストール Vundleを使ってらっしゃるなら、
.vimrc Bundle &#39;git://github.com/kien/ctrlp.vim.git&#39; Bundle &#39;git://github.com/tokorom/ctrlp-docset.git&#39; で、その他のかたは各自の環境に合わせて読み替えてください。
ctrlp-docset の設定 設定なしでも動く人がいるかもしれませんが、以下２つをご確認ください。
.vimrc # docsetutilコマンドの場所を指定する（docsetutilにPATHが通っていれば設定必要なし） let g:ctrlp_docset_docsetutil_command = &#39;/Applications/Xcode.</description>
    </item>
    
    <item>
      <title>もっと簡単にVimでObjective-Cのコード補完を実行する</title>
      <link>https://www.tokoro.me/posts/easy-objc-complement/</link>
      <pubDate>Mon, 14 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/easy-objc-complement/</guid>
      <description>概要 先日、 VimでObjective-Cのコード補完を実行する With Clang でVimでclangを使ったコード補完をする方法について紹介させていただきましたが、今回はそのUpdate版になります。
というのも、clang_completeにはg:clang_auto_user_optionsという素晴らしいオプションがあり、これによりclang_complete本体をいじらなくてもiOS用の設定を簡単に拡張できることが分かったためです。
具体的には、clang_completeともう１つ、後述の拙作の plugin を１つインストールいただき、
after/ftplugin/objc.vim let g:clang_auto_user_options = &#39;path, .clang_complete, ios&#39; という設定をするだけで多くのプロジェクトが .clang_complete ファイルなしでコード補完できるようになる見込みです（手元のプロジェクトは全て追加設定いらずでした）。 このオプションの中の、
path .clang_complete clang ※2013/1/20 追記 clangの項はclang_completeのバージョンアップでなくなりました
の３つ２つはclang_completeにデフォルト値で設定される値で、最後の
ios が今回作成したpluginにより追加できるオプションです。
clang_complete-getopts-ios clang_complete-getopts-iosが新しく作成した clang_complete の plugin です。
これを入れることで、clang_completeでのコード補完実行の際に、
&#39;-fblocks -fobjc-arc -D __IPHONE_OS_VERSION_MIN_REQUIRED=40300&#39;をオプションとして追加する カレントディレクトリ以下のディレクトリを全てIncludeファイル用の検索パスとして追加する カレントディレクトリ以下の *.pch を全て -include オプションとして追加する -F /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator6.0.sdk/System/Library/Frameworksをオプションとして追加する /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator6.0.sdk/usr/include以下のディレクトリを全てIncludeファイル用の検索パスとして追加する という５つのことを自動で行ってくれるようになり、.clang_completeファイルいらずになります。 要するに、前の記事 で手動で .clang_complete ファイルに設定した項目+αのことを自動でやってくれるようになります。
インストール方法 pluginをVundleなどでインストール # Vundleをご利用の場合 Bundle &#39;git://github.com/tokorom/clang_complete.git&#39; Bundle &#39;git://github.com/tokorom/clang_complete-getopts-ios.git&#39; after/ftplugin/objc.vim に以下のようにiosアプリ開発用の設定を加える let g:clang_auto_user_options = &#39;path, .clang_complete, ios&#39; この他、clang_complete 自体の設定などについては、 VimでObjective-Cのコード補完を実行する With Clang をご参照ください。</description>
    </item>
    
    <item>
      <title>Objective-Cで最近お気に入りのマクロ４つ</title>
      <link>https://www.tokoro.me/posts/objc-macro/</link>
      <pubDate>Wed, 09 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/objc-macro/</guid>
      <description>マクロ マクロの利用については賛否両論がありますが、ぼくはわりかし使います。
** ※2013/1/9 追記 **
上記のとおり独自のマクロを使うこと自体に賛否両論あります。
例えば独自のマクロを定義して利用することで、
他の人がコードを見たときに分かりづらくなる 思わぬ不具合が出るケースがある 名前の衝突リスクがある（マクロは名前空間が使えない） などのデメリットがあります。 特にチームや会社でのご利用の際にはよくよくご留意をお願いします。
1. [NSString stringWithFormat:] を簡単に NSString* message = [NSString stringWithFormat:@&amp;quot;HELLO %3.1d&amp;quot;, 333.333]; [NSString stringWithFormat:]はよく使うのだが長くて面倒&amp;hellip;とよく思ってしまう。
ということで、
#define NSPRINTF(f, ...) [NSString stringWithFormat:f, __VA_ARGS__] を定義して
NSString* message = NSPRINTF(@&amp;quot;HELLO %3.1d&amp;quot;, 333.333); としています。ちょっと楽！
** ※2013/1/9 追記 *
NSSPRINTFというネーミングは微妙。特にNSという冠詞を勝手に使うのがダメ。
元々のイメージはNSString+sprintfだったが再考すべし。
2. NSLocalizedString を簡単に NSString* message = NSLocalizedString(@&amp;quot;KEY&amp;quot;, nil); NSLocalizedStringもよく使うのだが長いしあまり使わない引数がつきまとって面倒&amp;hellip;とよく思ってしまう。
ということで、
#define LSTR(s) NSLocalizedString((s), nil) を定義して
NSString* message = LSTR(@&amp;quot;KEY&amp;quot;); としています。ちょっと楽！
3. クラスメソッドの利用を簡単に [LongLongLongNameClass classMethod]; 自クラスのクラスメソッドを使うときにクラス名が長いとインスタンスメソッドのselfと比べて面倒だなと思ってしまう。 ということで、</description>
    </item>
    
    <item>
      <title>Objective-Cで&#34;@dynamic&#34;の使いどころを考える</title>
      <link>https://www.tokoro.me/posts/objc-dynamic/</link>
      <pubDate>Sat, 05 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/objc-dynamic/</guid>
      <description>Objective-Cの @dynamic はお好きですか？ ぼくはけっこう好きです。
@synthesizeのほうは昔はほぼ必須で書かないといけなかったり Xcode4.4で省略できるようになった ことで有名ですが、いっぽうで@dynamicのほうはあまり日の目を浴びていない気がします。
そこで、今日は@dynamicについて再考してみることにしました。
以下、ぼくが思い返してみて@dynamicがこんなときに便利だったと感じたところを２点挙げさせていただきます。
みなさまのほうでも「こんなとき便利だよ」というのがありましたら是非ご教示ください。
クラスの内部実装が適当なのを隠すときに そもそもこの実装自体がどうかという話もあるのですが、リファクタリング前にひとまず雑な実装をしてしまうことはままあります。
例えば、ゲームスコアを管理するGameScoreクラスを作ったとして、その中で ハイスコア とかいくつかのスコアを管理する際、scoresというNSDictionaryインスタンスにささっと入れていたとします（ほんとは普通にプロパティにしたほうが良いですが例として）。
GameScore.m #import &amp;quot;GameScore.h&amp;quot; @interface GameScore () @property (strong) NSMutableDictionary* scores; @end @implementation GameScore - (id)init { if ((self = [super init])) { self.scores = [@{ @&amp;quot;highScore&amp;quot;: @1000, @&amp;quot;currentScore&amp;quot;: @530, @&amp;quot;friendScore&amp;quot;: @890, } mutableCopy]; } return self; } この ハイスコア を外（他のクラス）から参照させたい場合、どう実装しますか？
ダメそうな例 : NSDictionaryのインスタンスをそのまま公開してしまう GameScore.h @interface GameScore : NSObject @property (strong) NSMutableDictionary* scores; @end 手っ取り早いのはscoresプロパティをそのままPublicなプロパティとしてアクセス可能にしてしまう方法でしょうか。
たしかに簡単ですが、外部から内部データ（NSDictionary）を好きなようにいじられたり見られたりするのは避けたいところです。このままだとかなり密結合なかんじです。</description>
    </item>
    
    <item>
      <title>VimでObjective-Cのコード補完を実行する with clang</title>
      <link>https://www.tokoro.me/posts/clang-complete-for-vim/</link>
      <pubDate>Wed, 02 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/clang-complete-for-vim/</guid>
      <description>概要 VimやEmacsでiOSアプリ開発をするときに「Snippetとかちゃんと設定してればXcodeほどのコード補完は必要ない」と強がりを言ってはみるものの「本当はちょっとコード補完使いたいときあるんだよね」と思ってました。
そこで、重い腰をあげてVimでもObjective-Cのコード補完ができるよう設定してみました。
具体的には、
clangコマンドでのコード補完を試してみる その結果をもってVimの clang_complete プラグインを導入する という手順で実施しました。
結果として満足いく補完環境が整いましたので紹介させていただきます。
clangコマンドでのコード補完を試してみる clangコマンドはXcodeを使っていればはじめっから入っているコマンドです。
じつはこのclangコマンドを使うことでObjective-Cのコード補完が普通にできるとのこと。
具体的には、
// clang -cc1 -code-completion-at=ソースコード.m:行数:列数 ソースコード.m clang -cc1 -code-completion-at=Sample.m:20:5 Sample.m というコマンドになります。
例えば、
Classes/Controllers/MainViewController.m #import &amp;quot;MainViewController.h&amp;quot; @implementation MainViewController - (void)viewDidLoad { [super viewDidLoad]; NSArray* numbers = @[@1, @2, @3]; [numbers o } @end の [numbers o のところで補完をしたいとして、
clang -cc1 -code-completion-at=Classes/Controllers/MainViewController.m:16:12 Classes/Controllers/MainViewController.m というコマンドを実行してみます。
すると COMPLETION: ではじまる行が幾つか表示され、なんらか補完結果が出ているのが分かります。
同時に、xxx warnings and xxx errors generated. とエラーが発生しているのも確認できるかと思います。
clangによる補完時のオプション このエラーは、clangに対するオプションの不足によるものです。 そこでclangに対して以下のオプションを設定してあげます（※環境依存なので適宜読み替えてください）
-w
=&amp;gt; 全ての警告を無視する（コード補完では警告はいらない） -fblocks</description>
    </item>
    
    <item>
      <title>Mac &#43; Terminal &#43; tmux &#43; vim でクリップボードを快適に使う</title>
      <link>https://www.tokoro.me/posts/mac-terminal-japanese/</link>
      <pubDate>Mon, 31 Dec 2012 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/mac-terminal-japanese/</guid>
      <description>Macの初期設定のたびに混乱してるので再整理しておきます。
Mac Terminal tmux vim で開発をする人向けです。
まずはMacVim KaoriYa MacでVimを使うならひとまず MacVim KaoriYa は外せません。
日本語を扱う上で便利な設定がデフォルトで入ってます。
当然、Terminalでも Macvim KaoriYa を使いたいので、 .zshenv などに以下のaliasを設定してCUIで vi や vim を叩いたときにも MacVim KaoriYa が使われるようにします。
if [ -f /Applications/MacVim.app/Contents/MacOS/Vim ]; then alias vi=&#39;env LANG=ja_JP.UTF-8 /Applications/MacVim.app/Contents/MacOS/Vim &amp;quot;$@&amp;quot;&#39; alias vim=&#39;env LANG=ja_JP.UTF-8 /Applications/MacVim.app/Contents/MacOS/Vim &amp;quot;$@&amp;quot;&#39; fi tmux でも pbcopy/pbpaste が使えるようにする Macの tmux では pbcopy/pbpaste コマンドが正常に動作しないということなので、
こせきの技術日記 に従って対処しておきます。
この中の、
date | pbcopy までが成功すればOKです。
.vimrc にクリップボード利用の設定追加 .vimrc に
set clipboard=unnamed を追加しておきます。
fakeclip の導入 fakeclip をVimに追加することで、 tmux や screen を使っていてもVimのヤンク(y)やペースト(p)のときにクリップボード(正確には pbcopy/pbpaste )が使われるようになります。</description>
    </item>
    
    <item>
      <title>Objective-Cのテストクラスからプライベートメソッド/プロパティを参照したい</title>
      <link>https://www.tokoro.me/posts/objc-private-test/</link>
      <pubDate>Wed, 12 Sep 2012 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/objc-private-test/</guid>
      <description>dkfjさんが Objective-Cで、プライベートメソッド・プロパティにアクセスし、ユニットテストを実行する方法 という記事を書かれていました。
せっかくなので私がやっている方法も書かせていただきます。
テスト対象のクラス 以下のようにプライベートメソッドとプロパティを持ったExampleClassをテストするとします。
#import &amp;quot;ExampleClass.h&amp;quot; @interface ExampleClass() - (BOOL)privateMethod; @property (assign) BOOL flag; @end @implementation ExampleClass - (BOOL)privateMethod { return self.flag; } @end テストクラス 自分の場合は、こんなかんじでテストクラスでテスト対象のプライベートメソッドやプロパティを宣言し直して使ってます。
#import &amp;lt;GHUnitIOS/GHUnit.h&amp;gt; #import &amp;quot;ExampleClass.h&amp;quot; @interface ExampleClass (Private) - (BOOL)privateMethod; @property (assign) BOOL flag; @end @interface ExsampleClassTest : GHTestCase @end @implementation ExsampleClassTest - (void)testPrivateMethod { ExampleClass* example = [ExampleClass new]; GHAssertFalse([example privateMethod], nil); example.flag = YES; GHAssertTrue([example privateMethod], nil); } @end メリットとデメリット メリット プライベートメソッドを（テストクラス以外からは）プライベートなまま保てる デメリット 本体のほうのメソッドが変わったらテストクラスのほうの宣言も書き直す必要がある </description>
    </item>
    
    <item>
      <title>GHUnitのテストカバレッジをJenkinsで表示する</title>
      <link>https://www.tokoro.me/posts/ghunit-jenkins-coverage/</link>
      <pubDate>Sun, 02 Sep 2012 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/ghunit-jenkins-coverage/</guid>
      <description>概要 設定が完了すると、JenkinsでGHUnitのテストが実行された後に以下のようにテストカバレッジが参照できます。
設定がちょっとだけ面倒ですが、一度やって慣れてしまえばなんてことありません。
実際に動かしてみたサンプルプロジェクトは Github に置いてあります。
うまく動かない場合の設定の比較などにご参照ください。
なお、ここではiOSアプリ開発用としての紹介をさせていただきます。
事前準備 Jenkinsの導入 さくらVPSにJenkinsさんをインストールする GHUnitの導入 Jenkins を iOS アプリ開発に導入してみた (GHUnit編) GHUnitのiOS用frameworkをビルドするのが面倒な場合は、Github にビルド済みのものを置いてあるのでこれを使っていただいても構いません(2012/9/2時点でXcode 4.4.1 では問題なく利用できました)。
テストカバレッジを出力するためのプロジェクトの設定を変更する GHUnitを使っている場合はテスト用のターゲットにのみ設定すればOKです。
具体的には、以下のように
Generate Test Coverage Files Instrument Program Flow の２つに YES を設定します。
本来であれば上記だけで完了とできるのですが、現状だとXcodeにバグがあるというこでこのままだとJenkinsでのジョブ実行時に
Detected an attempt to call a symbol in system libraries that is not present on the iPhone: fopen$UNIX2003 called from function llvm_gcda_start_file in image Tests. というエラーが出ることになります。
この対処として、 main.m に以下コードを追記しておく必要があります。
FILE *fopen$UNIX2003(const char *filename, const char *mode) { return fopen(filename, mode); } size_t fwrite$UNIX2003(const void *ptr, size_t size, size_t nitems, FILE *stream) { return fwrite(ptr, size, nitems, stream); } 最後に、テスト用のターゲットの info.</description>
    </item>
    
    <item>
      <title>Objective-Cで少しでも疎結合なプログラムを書くためのチェックポイント</title>
      <link>https://www.tokoro.me/posts/safe-objc/</link>
      <pubDate>Fri, 17 Aug 2012 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/safe-objc/</guid>
      <description>チェック1. なんでもかんでもヘッダーファイルでimportしていませんか？ 例えば、こんなコードを書いていませんか？
#import &amp;quot;OtherLibrary1.h&amp;quot; #import &amp;quot;OtherLibrary2.h&amp;quot; @interface Library @property (strong) OtherLibrary1* otherLibrary1; @property (strong) OtherLibrary2* otherLibrary2; @property (assign) BOOL flag; @end Libraryというクラスを作り、そこでOtherLibrary1とOtherLibrary2をpublicなpropertyとする場合、当然のごとくOtherLibrary1とOtherLibrary2のimportが必要なわけですが、なにも考えずにヘッダーファイルでOtherLibrary1.hとOtherLibrary2.hをimportしてしまっていませんか？
そうしてしまうと、この Library.h をimportする全てのクラスに、OtherLibrary1.hとOtherLibrary2.hも芋づる式にimportすることを強要することになってしまいます。
実際にこの Library を使うクラスでは、otherLibrary1もotherLibrary2も使わないかもしれないですし、確実に使われるのでなければ、ヘッダーファイルでimportしないほうが疎結合なプログラムになります。
具体的にはこの状態だと、 OtherLibrary1もしくはOtherLibrary2が変更されると、Library.hをimportする全てのクラスにも影響が出る 状態になってしまっています。
以下、これを解消するための変更例です。
クラスの前方宣言を使い、ヘッダーファイルではimportしない @class OtherLibrary1; //&amp;lt; ここではimportしない @class OtherLibrary2; //&amp;lt; ここではimportしない @interface Library @property (strong) OtherLibrary1* otherLibrary1; @property (strong) OtherLibrary2* otherLibrary2; @property (assign) BOOL flag; @end #import &amp;quot;OtherLibrary1.h&amp;quot; #import &amp;quot;OtherLibrary2.h&amp;quot; @implementation Library // 略 @end このように、 @class による前方宣言だけしてあげれば、OtherLibrary1やOtherLibrary2をimportしなくてもpropertyの定義ができます。特定のクラスのポインタを使う定義をするだけなら、そのクラスの実装を知らなくてもそのクラスが存在するということだけを知っていれば済むためです。このように実装が確定していないクラスのポインタのことを Opaque pointer: (不透明ポインタ) と呼ぶそうです。</description>
    </item>
    
    <item>
      <title>Objective-Cで独自クラスに[]でアクセスする</title>
      <link>https://www.tokoro.me/posts/objc-subscripting/</link>
      <pubDate>Sun, 12 Aug 2012 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/objc-subscripting/</guid>
      <description>まず、Xcode4.4から使えるObjective-Cの新しい書き方については 前の記事 をご参照ください。
Xcode4.4からMacアプリ開発で使える新しいリテラル 上記記事には書いていないのですがMac向けのアプリではこの他にも、
array[1] でNSArrayの要素にアクセスできる dictionary[key] でNSDictionaryの要素にアクセスできる @YES/@NO でもNSNumberのインスタンスを作れる といった変更があります。
こちらについては残念ながらiOSアプリ開発ではまだ利用できません。
※ これらがターゲットがMacの場合には利用できてiOSの場合には利用できないということは、 @k_katsumi さんに教えてもらいました。
でも[]でアクセスする仕組み自体はiOSでも使えます! ところで、[]でインスタンスにアクセスするコードを書いたとき、これらはコンパイル時に、
// id obj = array[0]; のときはこれになります - (id)objectAtIndexedSubscript:(NSUInteger)index; // array[0] = obj; のときはこれになります - (void)setObject:(id)object atIndexedSubscript:(NSUInteger)index; // id obj = array[key]; のときはこれになります - (id)objectForKeyedSubscript:(id)key; // array[key] = obj; のときはこれになります - (void)setObject:(id)object forKeyedSubscript:(id)key; に変換されるそうです。
これらの変換自体はiOSがターゲットの場合でも行われているようです。
例えば独自クラスに上記メソッドを実装すると&amp;hellip; 例えば、以下のように適当なクラスに上記４つのメソッドを実装してみました。
@interface Wrapper : NSObject - (id)objectAtIndexedSubscript:(NSUInteger)index; - (void)setObject:(id)object atIndexedSubscript:(NSUInteger)index; - (id)objectForKeyedSubscript:(id)key; - (void)setObject:(id)object forKeyedSubscript:(id)key; @end #import &amp;quot;Wrapper.</description>
    </item>
    
    <item>
      <title>いまさらですがXcode4.4からiOS開発で使えるようになった新しいObjective-Cの書き方をまとめます</title>
      <link>https://www.tokoro.me/posts/objc-new-statements/</link>
      <pubDate>Sun, 12 Aug 2012 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/objc-new-statements/</guid>
      <description>もうほとんどのかたが既知の内容と思いますが、まとめさせていただきます。
これらは全てコンパイル時に事が済む類のものなので、iOS5だけでなくiOS4でも当然使えるというのが嬉しいですね!
Xcode4.4適用前 Xcode4.3までのこのコードを&amp;hellip;
#pragma mark - Private Category @interface Sample () @property (strong) NSNumber* i; @property (strong) NSNumber* c; @property (strong) NSNumber* f; @property (strong) NSArray* array; @property (strong) NSDictionary* dictionary; - (void)privateMethods1; - (void)privateMethods2; - (void)privateMethods3; @end #pragma mark - Main Implementation @implementation Sample @synthesize i = i_; @synthesize c = c_; @synthesize f = f_; @synthesize array = array_; @synthesize dictionary = dictionary_; - (void)privateMethods1 { [self privateMethods2]; [self privateMethods3]; } - (void)privateMethods2 { self.</description>
    </item>
    
    <item>
      <title>Jenkins@さくらVPSにOctopressのデプロイを任せてみる</title>
      <link>https://www.tokoro.me/posts/jenkins-octopress/</link>
      <pubDate>Sun, 29 Jul 2012 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/jenkins-octopress/</guid>
      <description>目的 Octopressで記事を書いたあと、 Bitbucket に git push origin source とするだけで Github Pages に勝手にデプロイされるようにする。
イメージ 自分はブログ記事を書き終わったら、Bitbucketに git push だけしてあとは放っておく Bitbucketは該当リポジトリが更新されると、さくらVPSのJenkinsのURLを叩く Jenkinsはそれを契機にBitbucketからファイル一式をcloneしてOctopresで記事を作成する Jenkinsは作成した記事をGithub Pagesにデプロイする 事前準備 Github PagesにOctopressでブログを投稿できるようにしておく =&amp;gt; まだなら このあたりを参照 さくらVPSを使えるようにしておく さくらVPSにJenkinsをインストールしておく =&amp;gt; まだなら こちらを参照 さくらVPSでGitを使えるようにしておく =&amp;gt; まだなら こちらを参照 Githubを使えるようにしておく Bitbucketを使えるようにしておく Jenkinsに入れておく必要のあるPlugin RVM Plugin JenkinsからBitbucketとGithubにアクセスできるようにする $ cd /var/lib/jenkins $ sudo -u jenkins -H /usr/local/bin/git config --global user.email &amp;quot;jenkins@your.domain&amp;quot; $ sudo -u jenkins -H /usr/local/bin/git config --global user.name &amp;quot;jenkins&amp;quot; $ sudo -u jenkins -H ssh-keygen -t rsa -C jenkins@your.</description>
    </item>
    
    <item>
      <title>JenkinsにBitbucketからビルド命令を出す際にIDとPasswordを埋め込まないようにする</title>
      <link>https://www.tokoro.me/posts/security-for-jenkins/</link>
      <pubDate>Sun, 29 Jul 2012 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/security-for-jenkins/</guid>
      <description>前の記事でBitbucketにpushしたのをトリガーにJenkinsでOctopressをデプロイするというのをやったのだが、このときは認証なしでJobの実行できるようになってしまっていた。
つまりこのままだと自分のJenkinsは認証なしで全てのJobが実行できてしまうという状態でよろしくない。
ひとつの解決索としてビルド命令用のユーザを作り、そのIDとPasswordをURLに直接埋め込んでしまうという方法も考えられるが、今回はそれを極力しない方向でがんばりたいと思う。
JenkinsにBitbucketからアクセスするためのユーザを追加 まずはBitbucketからJenkinsにアクセスする専用のユーザを作る。
※ ユーザの追加方法については このあたり を参照
今回は、bitbucket というユーザを追加した。
また、 Manage Jenkins -&amp;gt; Configure System で、
Access Control Authorization Matrix-based security bitbucketユーザに Job の Read だけチェック としておいて、bitbucketユーザが最低限のことのみ可能なように設定しておく。
このとき、Anonymousユーザの Job の Read にチェックがついていれば外しておく。
Jenkinsへのビルド命令専用のドメインを追加 これまでは jenkins.yourdomain というドメインでJenkinsにアクセスさせていたとして、ビルド命令専用の push-to-jenkins.yourdomain を追加した。
これはnginxが外部からのビルド命令だと分かるようにするための目印としての意味合いなので、ドメインを追加する以外の方法でも良い。
nginxに設定追加 nginxのconfに、以下のようにpush-to-jenkins.yourdomainへのアクセスをBasic認証つきでローカルのJenkinsのURLに委譲するよう設定を追加する。
server { listen 80; server_name push-to-jenkins.yourdomain; location / { proxy_pass http://localhost:8080; proxy_set_header Authorization &amp;quot;Basic XXXXXX&amp;quot;; } } XXXXXX の部分には実際には bitbucket:yourpassword というBasic認証のIDとPasswordの文字列をBase64エンコードした文字列を入れる必要がある。
Base64エンコードの方法が分からない場合は このあたり のサイトでエンコードした文字列をGETするのが手っ取り早い。
設定後にnginxを再起動しておくこと。
Bitbucketのほうの設定 該当リポジトリの Admin タブの Services を選択。</description>
    </item>
    
    <item>
      <title>さくらVPSにJenkinsさんをインストールする</title>
      <link>https://www.tokoro.me/posts/install-jenkins-to-sakura/</link>
      <pubDate>Tue, 24 Jul 2012 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/install-jenkins-to-sakura/</guid>
      <description>JDKのインストール Javaが未インストールならこちらから。
$ sudo yum install java-1.6.0-openjdk java-1.6.0-openjdk-devel Jenkinsのインストール 基本的に 公式ページ に書いてあるとおりにするだけ。
$ sudo wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat/jenkins.repo $ sudo rpm --import http://pkg.jenkins-ci.org/redhat/jenkins-ci.org.key $ sudo yum install jenkins Jenkinsの起動 $ sudo service jenkins start これでインストールと起動が完了。簡単すぎる！
試しに
$ curl http://localhost:8080/ とすると、
&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt; &amp;lt;title&amp;gt;Dashboard [Jenkins]&amp;lt;/title&amp;gt;... みたいなHTMLが出力されてJenkinsさんが動いているのを確認できるはず。
ついでにサーバ再起動時にJenkinsさんが自動で起動するようにしておく。
$ sudo chkconfig jenkins on nginxの設定 まず、nginxが未インストールなら
$ sudo yum install nginx でインストールしておく。
Jenkinsにnginx経由でアクセスするために、自分の場合は /etc/nginx/conf.d/virtual.conf に以下リバースプロキシの設定を加えた。
server { listen 80; server_name jenkins.自分の.ドメイン location / { proxy_pass http://localhost:8080; } } ここでは、 http://jenkins.</description>
    </item>
    
    <item>
      <title>Macにpandocをインストール中にhs-httpで引っかかったのを解消した手順</title>
      <link>https://www.tokoro.me/posts/install-pandoc/</link>
      <pubDate>Sun, 15 Jul 2012 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/install-pandoc/</guid>
      <description>hs-httpがインストールできない! Macにpandocを入れようと気軽にMacPortsで
$ sudo port install pandoc したところ hs-http のインストールのところでなにやらエラー&amp;hellip;
試しに hs-http だけインストールしてみたところ、
$ sudo port -d install hs-http ... Configuring HTTP-4000.1.1... ghc: could not execute: /usr/bin/gcc-4.2 Command failed: cd &amp;quot;/opt/local/var/macports/build/_opt_local_var_macports_sources_rsync.macports.org_release_ports_devel_hs-HTTP/hs-http/work/HTTP-4000.1.1&amp;quot; &amp;amp;&amp;amp; runhaskell Setup co nfigure --prefix=/opt/local --with-compiler=/opt/local/bin/ghc Exit code: 1 Error: org.macports.configure for port hs-http returned: configure failure: command execution failed DEBUG: Error code: NONE DEBUG: Backtrace: configure failure: command execution failed while executing &amp;quot;$procedure $targetname&amp;quot; Warning: targets not executed for hs-http: org.</description>
    </item>
    
    <item>
      <title>Octopressでソースコードの一部分だけを参照する</title>
      <link>https://www.tokoro.me/posts/octopress-part-of-codes/</link>
      <pubDate>Sun, 15 Jul 2012 00:00:00 +0000</pubDate>
      
      <guid>https://www.tokoro.me/posts/octopress-part-of-codes/</guid>
      <description>おさらい：Octopressでソースコードを表示する まずはおさらいでOctopressでソースコードを表示する方法は以下のとおり。
1. 指定のディレクトリにファイルを置く 置き場所は source/downloads/code 。
例えば、ここに sample/test.rb というファイルを置いておく。
$ mkdir -p source/downloads/code/sample $ cp test.rb source/downloads/code/sample/ 2. include_code でそのファイルを指定する {% include_code sample/test.rb %} これで↓のようにそのコードが表示できる。 {% include_code sample/test.rb %}
コードの全てでなく、指定した箇所だけ表示したい それでは、この test.rb の中の to_fraction というコードだけを表示したい場合はどうしたら良いだろう？
じつは現行のOctopressのデフォルトの状態ではそれができない(*1)。
ただ、この機能は v2.1 では既に実装済みのようで、Octopressを master ではなく 2.1 ブランチから取ってこればこのコードの一部分だけを表示する機能が使えるようになる。
この経緯については、 OctopressのPull request に記録がある。
2.1 ブランチをpullしてOctopressをアップデート $ git pull octopress 2.1 $ bundle install $ rake update_source $ rake update_style 以上で取り込み完了です。
masterでなく 2.1 からpullしていることに注意が必要。
include_code にstartとendを指定する あとは、↓のように include_code で start と end を指定するだけで、</description>
    </item>
    
  </channel>
</rss>
