<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>TOKOROM BLOG</title>
    <link>https://www.tokoro.me/</link>
    <description>Recent content on TOKOROM BLOG</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright © tokorom. All Rights Reserved.</copyright>
    <lastBuildDate>Mon, 26 Oct 2020 17:02:15 +0900</lastBuildDate>
    <image>
      <url>https://www.tokoro.me/img/hugo.png</url>
      <title>GoHugo.io</title>
      <link>https://www.tokoro.me/</link>
    </image>
    
	<atom:link href="https://www.tokoro.me/atom.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>iOS14で戻るボタンのタイトルを空欄にするきちんとした方法</title>
      <link>https://www.tokoro.me/posts/ios14_blank_back_button/</link>
      <pubDate>Mon, 26 Oct 2020 17:02:15 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/ios14_blank_back_button/</guid>
      <description>
        先にまとめ if #available(iOS 14.0, *) { navigationItem.backButtonDisplayMode = .minimal } else { navigationItem.backButtonTitle = &amp;quot; &amp;quot; }  でOK！
概要 iOS14のアップデートの1つに、
 ナビゲーションバーの戻るボタンを長押しすると、画面遷移のヒストリーが表示され、いくつか前の画面までいっきに戻ることができる  というのがありますよね。
ユーザー目線ではたいへん便利な機能ですが、例えば、デザイン的に「戻るのタイトルを空欄」にしていたりすると、
と、この長押し時の戻り先リストも空欄になってしまうなどの問題が出てきます。
iOS13以前の方法 iOS13以前では、例えば、
Xcodeで該当画面（戻り先の画面）のNavigation ItemのBack Buttonに空白を1つ入れるなどして、戻るのタイトルを消すワークアラウンドがありました。
しかし、これをすると、iOS 14以降では長押し時の戻り先リストがおかしくなってしまうわけです。
iOS14でのきちんとした方法 そのため、まずiOS14ではBack Buttonの設定はいじらないようにしましょう1。
そうすると当然、
このように戻るボタンのところに画面名が表示されてしまいます。
そのうえで、iOS14から追加されたUINavigationItemのbackButtonDisplayModeを設定します。
https://developer.apple.com/documentation/uikit/uinavigationitem/3656350-backbuttondisplaymode
戻り先のUIViewControllerで、
if #available(iOS 14.0, *) { navigationItem.backButtonDisplayMode = .minimal } else { navigationItem.backButtonTitle = &amp;quot; &amp;quot; }  と navigationItem.backButtonDisplayMode に .minimal を設定することで、戻るボタンのタイトルが非表示になります。
また、Back Buttonなどもいじっていないため、戻るボタン長押し時の戻り先のリストも、
のようにきちんと表示されます。
UINavigationItem.BackButtonDisplayMode なお、backButtonDisplayMode には以下の３種の値を設定できます。
      </description>
      
      <coverImage>https://www.tokoro.me/images/ios14_blank_back_button/top.png</coverImage>
      
    </item>
    
    <item>
      <title>iOSDC Japan 2020でHomeKitについてのセッションで登壇しました #iwillblog</title>
      <link>https://www.tokoro.me/posts/iosdc2020/</link>
      <pubDate>Tue, 06 Oct 2020 14:57:02 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/iosdc2020/</guid>
      <description>
        2020年9月に開催された iOSDC Japan 2020 今年も盛り上がりましたね！ 2020年は初のオンライン開催でオフラインにはない良さも再認識することができました。
私も HomeKit 2020 というセッションで発表者として参加しました。
概要 セッションの概要はこんな感じです。ご興味がある題材がありましたら是非セッションビデオをご覧ください！
HomeKit Frameworkざっくり入門  HomeKit Frameworkでどんなことができるのか HomeKitの構成 具体的に電球を点灯させるコードの紹介 隠しキャラクター（HomeKitがサポートしていない気圧）を参照するテクニック HomeKitだからこそできる具体例  時間指定でなく「日の入」「日の出」をトリガーに 家に「誰もいなくなったら」をトリガーに 自動点灯したライトをN秒後に消灯する 「部屋が明るければ」自動点灯させない    HomeKitのBridgeについて  Hueには電球、人感センサー、スイッチなどあるが直接HomeKit対応しているのはじつは&amp;hellip; オープンソースのソフトウェアBridge「Homebridge」  HomebridgeでHomeKit未対応製品をHomeKit対応  ルンバ、スマートロック、赤外線リモコンなどもHomeKit対応できる！ Homebridgeを利用する具体的な方法　 プラグインの自作  HomeKit ADKで作る自作アクセサリ  HomeKit ADK概要 Homebridgeとの違い ソフトウェアでHomeKit対応アクセサリーを作る！  セッションビデオ  スライド  HomeKit入門の無料公開 iOSDC 2020とほぼ同時に、ちょうど良いタイミングでZennというサービスが始まり、Web上で簡単に書籍を執筆・公開できるようになりました。
そのため、かねてよりどこかで公開しようと思っていた『HomeKit入門』1 をZennで無料公開しました。
https://zenn.dev/tokorom/books/homekit-framework
 　iOS 11リリース当時に執筆したものですが、HomeKit FrameworkにはiOS 12以降大きな変更は入っていませんので、現在でも十分有効な内容かと思います。
ご興味ありましたら是非ご参照ください！
  iOS 11 Programmingの第12章に掲載したものです https://peaks.
      </description>
      
      <coverImage>https://www.tokoro.me/images/iosdc2020/top.png</coverImage>
      
    </item>
    
    <item>
      <title>自宅のインターネット接続環境を改善して通信速度を30Mbpsから400Mbpsにした経緯</title>
      <link>https://www.tokoro.me/posts/improve-my-internet-connection/</link>
      <pubDate>Mon, 07 Sep 2020 16:56:36 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/improve-my-internet-connection/</guid>
      <description>
        Photo by Franck V. on Unsplash
改善のきっかけ 自宅のインターネット接続環境は、改善前は通信速度が 10Mbps〜40Mbps 程度でした。
これで特に不満もなく使っていたのですが、同じプロバイダーを使っている同僚の @kudakurage が
「IPv6にしてWi-Fiルーターをいいやつに変えたら500Mbps以上出るようになったよ」
と教えてくれたので、 絶対に負けてられない！ せっかくなので自分も改善してみよう！ と思ったのがきっかけです。
前置き 私はネットワークに関する専門的な知識を持ち合わせていないため、おかしなことを書いたりしているかもしれません。
間違いなどありましたらよろしければ Twitter までご連絡ください。
 以下、速度計測は全て Fast.com で実施しています 以下、速度計測は全て無線接続で実施しています  有線接続では計測していません Wi-Fi 6での計測はiPhone 11 Proを利用しています    改善前の状態    Key Value     通信速度 10〜40Mbps   プロバイダー Interlink ZOOT NEXT   IP IPv4   接続方式 PPPoE   LANケーブル CAT6のフラットケーブル   Wi-Fiルーター Apple AirMac Time Capsule   Wi-Fi規格 Wi-Fi 5 (11ac)    上で同僚と同じプロバイダーと書きましたが、正確には「IIJmioひかり」と固定IP用に「Interlink ZOOT NEXT」の2つのプロバイダーを契約しており、同僚は「IIJmioひかり」を常用していて私は「Interlink ZOOT NEXT」を常用していました。というのに後から気づいたため、はじめはInterlinkのほうで計測しています。IIJmioのほうに切り替えても速度はそれほど変わらなかった記憶があります。
      </description>
      
      <coverImage>https://www.tokoro.me/images/improve-my-internet-connection/top.jpg</coverImage>
      
    </item>
    
    <item>
      <title>apple/swift-formatをVimで使う</title>
      <link>https://www.tokoro.me/posts/vim-swift-format/</link>
      <pubDate>Mon, 17 Aug 2020 18:11:06 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/vim-swift-format/</guid>
      <description>
        皆々様におかれましては apple/swift-format を快適にご利用いただいていますでしょうか？1
swift-formatをXcodeのBuild Phasesに設定して利用したり、CIなどで利用されているかたも多いかと思います。
私もswift-formatを利用しはじめたのですが、私のメインエディタであるVimからswift-formatを利用するといった記事は今のところ見つかりません。 iOSアプリをVimでコーディングするプログラマーは希有ですのでそれもしかたがないことでしょう。
ということでVim+SwiftでiOSアプリを開発して6年（2020年8月現在）の私がこの記事を書くこととしました。
swift-formatを扱うVim Pluginの存在 2020年8月現在、残念ながらswift-formatを扱うVim Pluginは見つかりませんでした。これまで利用されていたSwiftLintやSwiftFormatのPluginは見つかるのですが、新しめなapple/swift-format用のものはないようです。
そのため、Pluginといっても大した機能は必要ないこともあり、自分で作ることにしました。
https://github.com/tokorom/vim-swift-format
事前に必要なもの swift-format とうぜん事前にswift-formatが必要です。
which swift-format  などで存在を確認してください2。
なければ現在ならbrewでもインストール可能です。
SwiftFormatというのは別のツールですので間違わないようご注意ください。
brew install swift-format  aleというVimのPlugin https://github.com/dense-analysis/ale
非同期にLintをかけるためのPluginです。
今回、swift-formatによるLintはこのaleを経由してかけるように作っています。
vim-swift-formatのセットアップ Vimへのインストール ご利用のプラグインマネージャなどでインストールの設定をしてください。例えばVim-Plugなら
Plug &#39;tokorom/vim-swift-format&#39;  です。
必須の設定 swift-formatによるLintをかけるにあたって以下の設定項目が必須です。.vimrcなど任意の場所に設定してください。
let g:ale_linters = { \ &#39;swift&#39;: [&#39;swift-format&#39;], \} let g:vim_swift_format_use_ale = 1  必要なら可能な設定 swift-formatの場所をフルパスで指定したい場合などは必要に応じて、
let g:vim_swift_format_executable = &#39;swift-format&#39; let g:vim_swift_format_lint_command = &#39;swift-format lint %s&#39; let g:vim_swift_format_format_command = &#39;swift-format format --in-place %s&#39;  これらの設定が可能です。
      </description>
      
      <coverImage>https://www.tokoro.me/images/vim-swift-format/top.png</coverImage>
      
    </item>
    
    <item>
      <title>iOSアプリの本番環境でのテストをプロモーションコードを使って行うマニュアル</title>
      <link>https://www.tokoro.me/posts/ios-promocode/</link>
      <pubDate>Tue, 21 Jul 2020 11:48:23 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/ios-promocode/</guid>
      <description>
        Photo by JJ Ying on Unsplash
 これは、プログラマー向けではなく、社内や社外のテスト担当者さん向けのマニュアルとして作成したものです。
2020年7月現在のApp Store Connectを使って、スクショ多めで具体的な操作方法をまとめます。
プロモーションコードの用途 公式な用途 プロモーションコードの用途ですがAppleのドキュメントでは、
 報道関係者やインフルエンサーがAppのApp内課金をいち早く利用できるようにするため
 とプロモーション用であることが説明されています。
リリース前のテスト用途 この他、アプリ開発者の間では、リリース前に
 App Storeに公開されるアプリと全く同じものをテスト  するためにも使われています。
プロモーションコードを使わなくてもTestflightによりほとんどのテストは可能ですが、場合によっては、
 Testflightでのテスト時にはテストの効率化のためのデバッグ機能を入れていて、App Storeで公開するアプリのみデバッグ機能を除外している Testflightでのテストだと購入のテストにAppleのSandbox環境が使われてしまうが、どうしてもProduction環境での購入テストをやっておきたい  などの理由により アプリをApp Storeで公開する前の最終テスト として利用できます。
プロモーションコードを発行できる条件 プロモーションコードは 審査が通って公開が可能な状態 のアプリに対してのみ発行できます。
そのため、App Storeで公開する前にプロモーションコードでのテストをしたい場合、
 アプリを審査に出す際に「このバージョンを手動でリリースする」を選択しておく 審査に通ったらプロモーションコードを発行してテストする テストが完了したら「このバージョンをリリースする」ボタンでアプリをApp Storeに公開する  という手順を踏む必要があります。
プロモーションコードの発行手順 App Store Connectにログインする https://appstoreconnect.apple.com/ にログインします。
Q. アカウントがないのでログインできません
A. 担当のかた or アプリの開発者に問い合わせてアカウントをもらってください
 ログインしたら マイApp をクリックして プロモーションコードを発行する対象のアプリ を開きます。
プロモーションコードのページを開く アプリのページを開いたら画面上側の 機能 を選択し、画面左側の プロモーションコード を選択してプロモーションコードのページを開きます。
      </description>
      
      <coverImage>https://www.tokoro.me/images/ios-promocode/top.jpg</coverImage>
      
    </item>
    
    <item>
      <title>iOSアプリの購入テストでSandboxアカウントを作って使うマニュアル</title>
      <link>https://www.tokoro.me/posts/ios-sandbox/</link>
      <pubDate>Wed, 08 Jul 2020 15:41:47 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/ios-sandbox/</guid>
      <description>
        Photo by Markus Spiske on Unsplash
 これは、プログラマー向けではなく、社内や社外のテスト担当者さん向けのマニュアルとして作成したものです。
2020年7月現在のApp Store Connectを使って、スクショ多めで具体的な操作方法をまとめます。
1. App Store Connectにログインする https://appstoreconnect.apple.com/ にログインします。
Q. アカウントがないのでログインできません
A. 担当のかた or アプリの開発者に問い合わせてアカウントをもらってください
 ログインしたら「ユーザとアクセス」をクリックして表示します。
2. Sandboxアカウント追加する 左のサイドメニューから「Sandbox テスター」を選んだあと、(+)マークの追加ボタンを押します。
姓名やメールアドレスを適切に入力します。
このときのポイントとして メールアドレスは実在するものでなくてもかまいません 1。 そのため、テスト用のアカウントはカジュアルに作成できます。 セキュリティ質問なども基本的には使いませんので適当でも大丈夫です2。
入力し終わったら[招待]ボタンを押します。
うまくいけば先程のテスター一覧に作成したSandboxアカウントが加わっているはずです。
Sandboxアカウントの作成はこれでおしまいです。
Q. 招待ボタンを押しても「エラーが発生しました。しばらくしてからもう一度お試しください。」となります。
A. メールアドレスが雑すぎるとそうなる場合があります。@マーク以降は自社のドメインにするほうが安全です。
 3. Sandboxアカウントを利用するうえでの注意点 Sandboxアカウントをプロダクション環境で使ってはいけません。
以下、Appleのドキュメントからの引用です。
 Sandboxテスターアカウントを使用して、テスト環境ではなく、iTunesなどのプロダクション環境に誤ってサインインした場合は、Sandboxアカウントは無効になり、以降使用できなくなります。この場合、新しいEメールアドレスを使用して新しいSandboxテスターアカウントを作成してください。
 プロダクション環境で使ってしまうと、そのSandboxアカウントは使えなくなってしまう、とのこと。
Sandboxは調子が悪くなることが多々あります。
Sandbox環境は調子が悪いことがよくあります。例えば購入テストの時に「iTunes Storeに接続できません」と出て購入に失敗することがよくあります。この場合、時間をおいて試していただくと問題なくなることもあります。
時間をおいても全く購入に成功しない場合、アプリのバグの場合もありますが、現在利用しているアカウントだとうまくいかない、というケースもあります。 その場合、別のSandboxアカウントに切り替えてトライするとうまくいくこともあります。
このあたりを踏まえたうえで、心配な場合はアプリ開発者に状況を報告して相談してみてください。
4. iPhone/iPadでSandboxアカウントを利用して購入テストをする ※iOS 13のスクショを撮っています。他のOSバージョンだと若干表示などが違うかもしれません。
iPhone/iPadの「設定」を開きます。
その中の「iTunes StoreとApp Store」を選びます。
その中の一番上に「Apple ID」があり、それが現在利用している本番用のApple IDです。
このApple IDが設定されている場合はここをタップして「サインアウト」をしておくとより安全にSandboxアカウントでの購入を試せます。
      </description>
      
      <coverImage>https://www.tokoro.me/images/ios-sandbox/top.jpg</coverImage>
      
    </item>
    
    <item>
      <title>Human Interface GuidelinesのApp Clipsの章の日本語訳</title>
      <link>https://www.tokoro.me/posts/hig-app-clips/</link>
      <pubDate>Tue, 07 Jul 2020 15:27:31 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/hig-app-clips/</guid>
      <description>
        前回、HIGのWidgetsの章を日本語訳した記事が好評だったので、今回はWidgesと同じくiOS 14の目玉機能の「App Clips」についても日本語訳しました。 Human Interface Guidelines (HIG) の App Clips がソースです。
2020年7月8日時点のものを訳します。
前回同様、訳しながらドキュメントの意図が正確に分からなかった部分や主観で大きく意訳した箇所は注釈に明記します。
App Clips App Clipはアプリの軽量版で、ユーザーにアプリをダウンロード・インストールさせずに、日常のタスクを素早く実行させることができます。 ユーザーは様々な状況や目的でApp Clipを見つけ、利用できます。 物理的な場所では、NFCタグや視覚的なコードをスキャンしてApp Clipを起動します。 デバイス上では、位置情報に基づくSiriからの提案、地図アプリ、ウェブサイトのSmart App Banners、メッセージアプリで友達が共有してくれたリンクをタップする、などからApp Clipsを起動します。
あなたのアプリが、限られた時間の中でタスクを実行するのに役立つ体験（in-the-moment experience）を提供しているなら、App Clipを導入することを考えてみましょう。 例えば、
 レンタル自転車にNFCタグを付け、それをスキャンしてApp Clipを起動し、その自転車をレンタルしてもらうことができます。 コーヒーショップでは、ウェブサイトにSmart App Bannerを設置して、そこからすぐに注文できる事前注文用のApp Clipを提供することができます。ユーザーはメッセージアプリでそのウェブサイトへのリンクを友達1に共有し、共有された友達もそのリンクをタップするだけでApp Clipから注文できます。 レストランでは、ユーザーが地図アプリやSiriからの提案からApp Clipを起動できるようにしたり、テーブルでNFCタグをスキャンしてもらいApp Clipで食事の支払いをするようにできます。 美術館では、来館者に展示品の名札の横にあるQRコード2をスキャンしてもらい、App ClipでARコンテンツを表示したり、音声解説を提供したりできます。  App Clipは、アプリをインストールしていないユーザーにアプリの機能の一部をシェアできる強力な方法です。 開発者向けのガイドは App Clips を参照してください。
優れたApp Clipのデザイン 本質的な機能にフォーカスしましょう。 App Clipのインタラクションは素早く、集中して行われるべきです。 目の前のタスクを達成するために必要な機能に限定してください。 高度な機能や複雑な機能はアプリのために取っておきましょう。
App Clipをマーケティング目的だけに使用してはいけません。 App Clipは真の価値を提供し、人々がタスクを達成するのに役立つものでなければなりません。 サービスや製品を宣伝するための手段として使用しないでください。
直線的で使いやすく、焦点を絞ったユーザーインターフェースをデザインしましょう。 App Clipには、タブバーや複雑なナビゲーション、設定があってはいけません。 画面の数や入力フォームの数も最小限に抑えましょう。 余分な情報を削り、できる限りシンプルなユーザーインターフェースにしてください。
起動時には、最適な画面を表示しましょう。 不要なステップをスキップして、ユーザーの現在の状況に最も適した画面をすぐに表示するようにしてください。
ユーザーがすぐに利用できるようにしましょう。 App Clipには本当に必要なアセットのみ含めてください。 スプラッシュ画面を入れるなどしてユーザーに起動を待たせるようなことをしてはいけません。
      </description>
      
      <coverImage>https://www.tokoro.me/images/hig-app-clips/top.png</coverImage>
      
    </item>
    
    <item>
      <title>Human Interface GuidelinesのWidgetsの章の日本語訳</title>
      <link>https://www.tokoro.me/posts/hig-widgets/</link>
      <pubDate>Thu, 02 Jul 2020 17:32:57 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/hig-widgets/</guid>
      <description>
        WWDC20でiOS 14の新機能として発表されたWidgetsについて勉強するため、Human Interface Guidelines (HIG) の Widgetsの章 を日本語訳します。
日本語で理解しやすいよう、ぼくの感性で意訳しちゃう部分もありますのでご了承ください。 訳しながらドキュメントの意図が正確に分からなかった部分は注釈に明記します。
2020年7月3日時点のものを訳します。
Widgets Widgetにより、アプリの重要なコンテンツをiPhone、iPad、Mac上の一目で分かる場所に表示できます。 Widgetは便利で楽しく、iPhoneのホーム画面をユーザーごとにパーソナライズするのにも役立ちます。
Widgetは、iOS 14以降と macOS 11以降で利用できます。 Widget Extensionを作成する という開発者向けのガイド記事があります。
Widgetsの詳細 Widgetには小、中、大の３つのサイズがあります。 iPhone、iPad、Macのどのプラットフォームでも、ユーザーはWidgetギャラリーからWidgetを見つけ、お好みのサイズを選べます。 また、ユーザーは後からWidgetを好きな場所に移動させたり、WidgetごとにWidgetが用意したパラメータを設定することができます。 例えば、ホーム画面に小さなお天気Widgetをいくつか設置して、それぞれのWidgetに別々の場所の天気を表示する、など。 Widgetは、iPhoneならホーム画面やTodayビュー、iPadならTodayビュー、macOSなら通知センターに設置できます。
iPhoneとiPadではWidgetギャラリーの中にスマートスタックがあります。 スマートスタックにはユーザーがよく使うアプリのWidgetがデフォルトで含まれています（後から変更もできます）。 スマートスタックはiPhoneのホーム画面と、iPhone/iPadのTodayビューに設置できます。 スマートスタックは時間とともにだんだんと賢くなり、Siriが自動で現在の状況に適したWidgetを一番上に表示してくれます。 また、ユーザーが自分で作ったWidgetのスタックでも、スタックの設定からスマート回転（Smart Rotate）をOnにすれば、Siriによる最適なWidgetの自動表示が有効になります。
 NOTE
iOS 13以前のiOS用に作られた古いWidgetはホーム画面では利用できませんが、Todayビューの下部やmacOSの通知センターでは引き続き利用できます。
 使いやすく焦点を絞ったWidgetの作成 Widgetをタップすることでアプリ本体を開きアプリ内でより多くのことをできますが、Widgetの主な目的はユーザーがアプリ本体を開かなくてもタイムリーにユーザーごとにパーソナライズされた少量の情報を表示することです。 Widgetで実現すべき1つのアイデアを特定し、表示する情報の焦点を絞ることが、Widgtetのデザインプロセスにおける重要な最初のステップです。
Widgetで実現するアイデアは1つに集中させてください。 ほとんどの場合はアプリのメインアイデアをWidgetに適用できるでしょう。 例えば、天気アプリでは特定の場所の天気を表示し、カロリートラッキングアプリではその日の消費カロリーを表示し、ニュースアプリではトレンドを表示するなどが考えられます。 また、ゲームアプリでキャラクターのステータスを表示したり、お絵かきアプリでお気に入りのスケッチを表示したりと、アプリのメインアイデアの1つの部分に焦点を当てるのも効果的です。
どのサイズのWidgetでも、Widgetのアイデアに直接関係する情報のみを表示してください。 大きなWidgetでは、より多くのデータを表示したり、より詳細な情報を表示することができますが、Widgetのアイデアに集中することが重要です。
例えば天気アプリの場合、小サイズのWidgetには現在の気温と天気、その日の最高気温と最低気温を表示します。
中サイズのWidgetには小サイズと同じ情報に加えて6時間分の時間ごとの予報も表示します。
大サイズのWidgetには6時間分の予報に加え、5日後までの予報も表示します。
アプリ本体を起動するだけのWidgetは避けましょう。 ユーザーがWidgetを評価するのは、意味のあるコンテンツにすぐにアクセスできるからであって、アプリを開くためのショートカットになるからではありません。
Widgetを複数のサイズで提供することで付加価値が得られる場合は、複数のサイズを提供しましょう。 小さいWidgetのコンテンツを拡大してエリアを埋めただけの大きなWidgetを作るのは避けましょう。すべてのサイズのWidgetを提供することよりも、あなたのアイデアを完璧に表現できる１つのサイズのWidgetを作成することのほうが重要です。
1日を通してダイナミックに変化することが期待されます。 Widgetの表示に変化がなければ、ユーザーはWidgetを目立つ位置に置き続けようとは思わないでしょう。 Widgetは分刻みで更新されるわけではありませんが、頻繁に見てもらうWidgetにするためにはコンテンツの鮮度を保つことが重要です。
驚きと喜びを与えてください。 例えばカレンダーWidgetなら、誕生日や祝日に特別な表示をすることができそうです。
Widgetの設定とインタラクティブ性 Widgetに設定すべき項目がある場合は設定可能なWidgetにしましょう。 多くの場合、Widgetに有用なコンテンツを表示するためには、ユーザーが見たい情報をあらかじめ指定する必要があります。 例えば、天気Widgetでは場所を選択したり、株価Widgetでは表示する株価を選択したりする必要があります。 一方で、ポッドキャストWidgetなら、最近のコンテンツを表示するようにあらかじめ設定されているので、カスタマイズする必要はありません。 設定可能なWidgetを作成する場合は、あまり多くの設定を要求したり、複雑な情報を要求したりすることは避けてください。 Widgetの設定画面はOSが自動的に生成してくれるので設定画面を自分で作る必要はありません。 開発者向けに 設定可能なWidgetを作成する というガイド記事もあります。
Widgetをタップしたときに、アプリの適切な画面を開くようにしましょう。 ユーザーがWidgetをタップすると、Widgetはアプリ本体にDeep Linkし、Widgetのコンテンツに直接関連する詳細情報やアクションを提供することができます。 例えば、ユーザーが特定の株価を表示しているWidgetをタップすると、株価アプリのその株価の詳細な情報を表示する画面を開きます。 また、ウォッチリストの一部を表示しているWidgetをタップすると、アプリが開いて全てのウォッチリストを確認できます。
      </description>
      
      <coverImage>https://www.tokoro.me/images/hig-widgets/top.png</coverImage>
      
    </item>
    
    <item>
      <title>Swift AWS Lambda Runtimeで犬の写真を毎朝Slackに送ってみる</title>
      <link>https://www.tokoro.me/posts/swift-aws-lambda-runtime2/</link>
      <pubDate>Mon, 15 Jun 2020 14:25:23 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/swift-aws-lambda-runtime2/</guid>
      <description>
        導入 前回の Swift AWS Lambda Runtimeのサンプルをデプロイしてみた の続きです。
特に犬の写真を毎朝送ってほしいというわけではないですが、Swift AWS Lambda Runtimeを試すにあたっての題材として、
 AWS Lambdaのスケジュール式トリガーで毎朝自動で実行する 画像検索APIで犬の写真をランダムに取ってくる それをSlackに送る  というのをやってみます。
画像検索API 画像検索APIは手っ取り早く使えそうなAzureの Image Search API を使ってみます。 Azureのアカウントさえ作れば、月1000回までは無料で叩けるようです。
curlで叩くとすると、
curl &#39;https://api.cognitive.microsoft.com/bing/v7.0/images/search?q=dog&#39; \ -H &#39;Ocp-Apim-Subscription-Key: YOUR_KEY&#39;  となります。
 リクエストパラメータに q=検索ワード リクエストヘッダーに Ocp-Apim-Subscription-Key: YOUR_KEY  を渡します1。
Slackへの通知 Slackの Incoming Webhook用のURLを取得します。
URLを取得したら、curlで叩くとすると、
curl -X POST -H &#39;Content-type: application/json&#39; \ --data &#39;{&amp;quot;text&amp;quot;:&amp;quot;犬の画像のURL&amp;quot;}&#39; \ https://hooks.slack.com/services/your/incoming/webhook  とするだけです。
 POSTデータで{&amp;quot;text&amp;quot;:&amp;quot;犬の画像のURL&amp;quot;}  を送ってあげるだけですね。
Lambda関数を作る これで画像検索APIとSlackへの通知部分は準備できたので、あとはメインディッシュのLambda関数を作るだけです。
Packageの作成 まずは、
swift package init --type executable --name DogImage  とPackageを作り、 GitHub上のサンプル をベースにPackage.
      </description>
      
      <coverImage>https://www.tokoro.me/images/swift-aws-lambda-runtime/top.png</coverImage>
      
    </item>
    
    <item>
      <title>Swift AWS Lambda Runtimeのサンプルをデプロイしてみた</title>
      <link>https://www.tokoro.me/posts/swift-aws-lambda-runtime/</link>
      <pubDate>Thu, 11 Jun 2020 14:57:28 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/swift-aws-lambda-runtime/</guid>
      <description>
        導入 先日（2020/5/29）、Swift AWS Lambda Runtimeが発表されましたね！
https://swift.org/blog/aws-lambda-runtime/
以前から Custom AWS Lambda runtimes を使い、自分でも実現することができましたが、このオフィシャルなライブラリを使い、よりシンプルに安全にSwift製AWS Lambda関数を構築できるようになります。
swift.orgの説明には、
 The library is an implementation of the AWS Lambda Runtime API and uses an embedded asynchronous HTTP Client that is fine-tuned for performance in the AWS Runtime context. The library provides a multi-tier API that allows building a range of Lambda functions: From quick and simple closures to complex, performance-sensitive event handlers.
  AWS Lambda runtime用にパフォーマンスを調整した非同期HTTPクライアントが組み込まれている さまざまな種類のLambda関数を作るのに便利なAPIを提供している  とあります。
      </description>
      
      <coverImage>https://www.tokoro.me/images/swift-aws-lambda-runtime/top.png</coverImage>
      
    </item>
    
    <item>
      <title>Github ActionsからSlackへ通知するのを良い感じにしたい</title>
      <link>https://www.tokoro.me/posts/github-actions-context/</link>
      <pubDate>Wed, 13 May 2020 17:26:38 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/github-actions-context/</guid>
      <description>
        この記事はpushをトリガーとしたGitHub Actionsのワークフローを前提として書いています。
概要 GitHub Actions、簡単便利で良いですね！
ぼくも遅まきながら使いはじめ、先日、Git pushをトリガーにデプロイしてSlackで通知、とよくあるワークフローを追加して運用しはじめました。
Slackへの通知も Marketplace に数ある既存Actionを選んで利用すれば、すぐに実現できました。すごい！
ぼくはこんな感じにしたかった とはいえ、贅沢を言えば、ぼくは
 レガシーなCustom integrationsのIncoming Webhooksでなく、きちんと新しいIncoming Webhooksでやりたい  ref: https://api.slack.com/legacy/custom-integrations#incoming-webhooks   Action独自のパラメータでなくSlackが定義しているMessage payloadsのフィールドをそのまま指定したい  ref: https://api.slack.com/reference/messaging/payload   GitHubで変更差分を見るためのURLを追加したりとか、お好みでカスタムしたい  と思い、意外とそれが叶う既存Actionが見つからなかったため、GitHub Actionsを作る練習も兼ねて、自作することにしました。
作ったActionは https://github.com/marketplace/actions/slack-incoming-webhook です。
実際の通知 テキストメッセージ送るだけ テキストメッセージを送るだけなら、どのActionを使っても同じようなものですが、こんな感じに
 Incoming WebhookのURLをenvに指定 textフィールドを指定  フィールド名を SlackのPayloadの仕様 に合わせてます    の２つだけ設定すると、
- name: Slack Notification uses: tokorom/action-slack-incoming-webhook@master env: INCOMING_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }} with: text: Hello, Slack!  こんな感じにSlackにメッセージを送れます。
いろいろカスタム 次に、textだけでなく、attachmentsフィールドも指定して、
      </description>
      
      <coverImage>https://www.tokoro.me/images/github-actions-context/github-actions.png</coverImage>
      
    </item>
    
    <item>
      <title>Vimにスクショを直接Markdownで貼り付ける</title>
      <link>https://www.tokoro.me/posts/vim-markdown-paste-from-clipboard/</link>
      <pubDate>Thu, 30 Apr 2020 18:01:01 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/vim-markdown-paste-from-clipboard/</guid>
      <description>
        Photo by Jae Park on Unsplash
前回 前回の記事では、画像ファイルをVimにドラッグ＆ドロップして、それをコマンド一発で、
 ImageOptimで画像を最適化 記事ごとの画像ディレクトリを自動作成してそこに画像をコピー Vimに ![image](/images/記事名/画像名) とMarkdown方式で埋め込む  という便利環境を作りました。
そのときの課題として「どうせなら既存画像だけじゃなくてスクショもコマンド一発でVimにMarkdown形式で貼り付けたいなあ」というのがありました。
今回はそこを解決します！
pbpasteはダメだった なんとなくpbpasteコマンドでゴニョゴニョするんだろうな思っていたのですが、pbpasteはテキストしか扱えないということがわかりました&amp;hellip;
screencaptureコマンドを使う しかしMacにはscreencaptureというコマンドがあり、
screencapture -i 出力ファイル名  とすると、shift + command + 4 で起動するインタラクティブなスクショモードを開始し、撮影後のスクショを指定したファイル名で保存してくれる、ということがわかりました。
vim pluginを拡張 前回、特定のコマンドを実行して、Vimの現在行を置き換えるpluginを作って使ったのですが、今回から、
 現在行の画像ファイル名を使って画像を適切に埋め込むコマンド スクショを撮影して現在行に埋め込むコマンド  の２つを使い分ける必要が出てきました。
そのため、前回のpluginを少し拡張して、
command! -nargs=0 MarkdownImageFromLine :call vim_replace_current_line#execute(&amp;quot;./.vim-replace-current-line/markdown-image-from-line&amp;quot;) command! -nargs=0 MarkdownImageWithScreenshot :call vim_replace_current_line#execute(&amp;quot;./.vim-replace-current-line/markdown-image-with-screenshot&amp;quot;)  とvimrcで好きなコマンド名でそれぞれ別のコマンドを叩けるようにしました。
今回のものは:MarkdownImageWithScreenshotというコマンドをVim上で叩くと、markdown-image-with-screenshotというシェルコマンドを実行し、そのレスポンスを現在行に埋め込む、という形です。
仕組み自体は前回と変わりません。
このpluginは GitHub に置いてあります。
スクショを撮影して&amp;hellip;のコマンド markdown-image-with-screenshotコマンドの具体的な中身は、
#! /bin/sh IMAGEDIR=&amp;quot;content/images/$2&amp;quot; CURRENTTIME=`date +%s` IMAGEFILENAME=&amp;quot;ss-${CURRENTTIME}.png&amp;quot; TARGET=&amp;quot;${IMAGEDIR}/${IMAGEFILENAME}&amp;quot; IMAGETAG=&amp;quot;![image](/images/$2/${IMAGEFILENAME})&amp;quot; mkdir -p ${IMAGEDIR} screencapture -i &amp;quot;${TARGET}&amp;quot; echo &amp;quot;${IMAGETAG}&amp;quot; IMAGEOPTIM=&amp;quot;open -a ImageOptim&amp;quot; `${IMAGEOPTIM} ${TARGET}`  です。
      </description>
      
      <coverImage>https://www.tokoro.me/images/vim-markdown-paste-from-clipboard/cover.png</coverImage>
      
    </item>
    
    <item>
      <title>VimでMarkdown形式でブログ記事を書くときに簡単に画像を埋め込む方法</title>
      <link>https://www.tokoro.me/posts/vim-markdown-image-tool/</link>
      <pubDate>Tue, 31 Mar 2020 16:38:32 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/vim-markdown-image-tool/</guid>
      <description>
        Photo by Victor Grabarczyk on Unsplash
ブログ記事書くとき画像を埋め込むのが面倒 こういったブログ記事は、皆さんどういう執筆環境で書いているでしょうか？
最近だとHugoなどの静的サイトジェネレータを利用することも多いのではないでしょうか。 この記事もHugoで運用しています。
記事を投稿するときは、いつもVimでさらっとMarkdown形式で書き上げ、ぱぱっとデプロイコマンドを打つだけで簡単便利な環境なのですが、唯一、記事に画像を埋め込むのだけが面倒だと感じてます。
特に、いわゆるブログサービスを利用している場合には、記事作成ページに埋め込みたい画像をドラッグ＆ドロップするだけで画像をアップロード＆埋め込みできてしまうので、それとの比較で面倒さが際立ちます。
手動での画像埋め込み手順 これまで手動で画像を埋め込む際には、このブログ記事の場合だと、
 各記事用の画像ディレクトリとして content/images/記事名 ディレクトリを作成 埋め込みたい画像を content/images/記事名 以下にコピー 記事内に ![image](/images/記事名/画像名) を埋め込む 必要に応じてImageOptimなどで画像の最適化  をしていました。
決して難しいことはありませんが地味に面倒でした。
ドラッグ＆ドロップでなんとかならない？ 結論として、私の執筆環境である「Terminal + Vim」ではドラッグ＆ドロップをうまくハンドリングする方法がわからず、ドラッグ＆ドロップだけでなんとかはなっていません。
ただ、TerminalのVim上に画像ファイルをドラッグ＆ドロップすると、その画像ファイルの絶対パスがVimに埋め込まれますので、その行でワンコマンドかますだけでなんとかなりそうだなと思い、Vim用のpluginを作りました。
具体的には、デスクトップ上のdog.jpgをドラッグ＆ドロップすると、Vim上に
/Users/tokorom/Desktop/dog.jpg  が埋め込まれますので、この行でコマンドを打ち、あとは必要なことを自動でやってくれる、という方式です。
現在行のファイルパスに対してなにかをするplugin このファイルパスに対してなにをしたいかは執筆環境により異なりますので、pluginに追加したのは、
function vim_replace_current_line#execute() let line = getline(&#39;.&#39;) let result = system(g:vim_replace_current_line#command . &#39; &#39; . expand(&#39;%&#39;) . &#39; &#39; . expand(&#39;%:t:r&#39;) . &#39; &#39; . trim(line)) call setline(&#39;.&#39;, trim(result)) endfunction  という３行のシンプルなfunction１つだけです。
      </description>
      
      <coverImage>https://www.tokoro.me/images/posts/vim-markdown-image-tool/dog.jpg</coverImage>
      
    </item>
    
    <item>
      <title>５分で終わるFirebase App Distribution（プロジェクト作成からテスターへの配信まで）</title>
      <link>https://www.tokoro.me/posts/firebsae-app-distribution/</link>
      <pubDate>Mon, 10 Feb 2020 10:43:31 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/firebsae-app-distribution/</guid>
      <description>
        Firebase App Distiribution 先日BETA公開されたFirebase App Distributionですが2020年3月終了のFabricからの移行先としてはもっとも有力ですよね1。
先日「Firebaseを利用していない既存アプリを配信するためだけにFirebase App Distributionを使いたい！」と思い試してみたら、あまりにも簡単で「これは10分で設定から配信まで完了するんじゃない？」と思い、実際に、
 Firebase未導入のビルド可能なプロジェクトがある状態 Firebaseのプロジェクトを作成するところから開始 配信用にアプリをビルドしてFirebase App Distributionでテスターに配信するところを終了  という条件で実際にストップウォッチで測ってやってみたところ、なんと「4分43秒」で終わりました！
この記事用にスクショを撮影しながらでもこのタイムだったので、本気でタイムアタックしたら3分切れると思います。
ということで「10分で終わるFirebase App Distribution」という記事を書く予定だったのを「5分で終わるFirebase App Distribution」に変更してお届けします。
そもそも アプリにFirebaseを導入するには基本的にはfirebase-ios-sdkをアプリに組み込む必要があります。
しかし、App Distributionだけを利用したい場合にはこのSDKの組み込みは不要です。この記事ではSDK組み込みをスキップしていますので、AnalyticsなどFirebaseの他機能を利用したい場合には他のチュートリアルをご利用ください。
設定チュートリアル（実際の手順） Firebaseのプロジェクトを作成  まずはFirebaseのConsoleにをブラウザで開いてプロジェクトを作成します   今回はApp Distributionのみ利用するので「Googleアナリティクス」はOffにしておきます   プロジェクトを作成したらここにiOSアプリ（配信しようとしているもの）を追加します   設定が必要なのはバンドルIDだけです XcodeのプロジェクトからBundle Identifierをコピーしてペーストします   今回は「設定ファイルのダウンロード」「Firebase SDKの追加」「初期化コードの追加」はスキップしてしまいます そのまま「コンソールに進む」としてしまってOK  これでFirebaseのプロジェクトが作成され、配信するアプリを登録できました。
実際に配信する それでは、実際にアプリをApp Distributionで配信してみましょう
 まず、アプリをArchiveして適当な場所にエクスポートします エクスポートしたアプリのipaをApp Distributionのページにドラッグ＆ドロップします   アップロードが終わったらテスターのメールアドレスを追加します  これでテスターに配信完了です！
おわり これだけで終わりです。
あとはテスターにこんなメールが届いているはずですので、
「Get setup」からインストールしてもらうだけです。
この記事で書いていないこと  AdHoc or Enterprise?
      </description>
      
      <coverImage>https://www.tokoro.me/images/posts/firebase-app-distribution/3-create-app.png</coverImage>
      
    </item>
    
    <item>
      <title>SwiftUIアプリを24時間で作ってリリースするひとりハッカソンの結果報告</title>
      <link>https://www.tokoro.me/posts/swiftui-hackathon/</link>
      <pubDate>Mon, 27 Jan 2020 14:32:55 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/swiftui-hackathon/</guid>
      <description>
        2019年はSwiftUI誕生の年 2019年のSwiftUIの発表はたいへんインパクトがありましたね！ Objective-CからSwiftへの変遷と同様に、ここ数年で間違いなくSwiftUIがiOSアプリ開発のスタンダードになるものと思います。
いっぽうでSwiftUIはまだまだ機能不足、情報不足で実際にリリースする案件に適用するには心許ないというのが2020年1月時点での現状です。特に自社のメインサービスやクライアントワークでSwiftUIの導入を決断をするのはなかなか難しい時期かもしれません。
また次の6月のWWDCでアップデートが発表され状況は変わってくると思いますが、それを待つのも&amp;hellip;
ということでハッカソン ということで、冬休みにひとりでハッカソンを実施して、
 24時間でSwiftUIでiOSアプリを開発して AppStoreでリリースする  ところまでやる！ということにしました。
自分で勝手に企画して出すアプリですのでSwiftUIを使っても誰にも文句は言われません！
必須利用技術 このハッカソン企画での必須利用技術は、
 SwiftUI Firebase（Firestore） Sign in with Apple  の３つとしました。
SwiftUI はもちろんですが、ローカルオンリーで動作するアプリだとSwiftUIの検証には弱いかなと思い、サーバにデータを保管するようにしバックエンドには Firebase(Firestore) を利用することにしました。 また、SwiftUIを採用する時点でターゲットOSがiOS 13以降になるので、ついでにiOS 13の新要素 Sign in with Apple でのSign inを実装することにしました。
リリースの定義 今回はゴールであるリリースの定義を、
 アプリを開発し終えて AppStore用のメタデータやスクリーンショットを作って投稿して 実際に審査に出す  ところまで、としました。
作るアプリ 作るアプリはちょうど自分が欲しいと思っていた「こどもたちのお金を親が管理するアプリ」にしました。
Photo by Michael Longmire on Unsplash
解決したい課題 我が家ではこどもたちにお金の教育を兼ねて毎月おこづかいを渡しているのですが、
 先月のおこづかい渡したっけ？渡してなかったけ？とよくわからなくなる お年玉が高額で幼稚園児に管理させるのが不安（かといって子供の銀行口座を作るのは面倒） 弟が姉の貯金箱を漁る事件が発生！ お店でこどもが「おこづかいでこのおもちゃ買いたい！」という時におこづかいを持ってきていない ○○カメラでおこづかいでおもちゃを買わせたいが、ほんとは〇〇カメラのポイント使っちゃいたい！ ほんとは余っている〇〇Payで支払いたい！  など様々な悩みが出てきました。
解決するための機能 これらを解決するためには、
 こどもに現金を持たせないで親が残高だけ管理すれば十分 記録さえ残せば、親の財布が銀行代わりで、財布から出金、財布に入金でかまわない 入金、出金の記録は親もあとから削除・修正できないようにして証拠として残せばこどもも安心 普段使いの少額の現金はその残高から出金してこどもに渡せばOK おこづかいを使う時は親の財布から出金すればよいので〇〇カメラのポイントも○○Payもクレジットカードも使い放題！  と考え、シンプルに親のアプリでこどものおこづかい残高を管理するのがよいと仮定しました。
      </description>
      
      <coverImage>https://www.tokoro.me/images/apple/swiftui.png</coverImage>
      
    </item>
    
    <item>
      <title>HomeKit ADKでSlackにメッセージ送信するアクセサリを作ってみる</title>
      <link>https://www.tokoro.me/posts/homekitadk/</link>
      <pubDate>Mon, 23 Dec 2019 11:47:15 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/homekitadk/</guid>
      <description>
        HomeKitADKのオープンソース化 つい先日（2019/12/18）、AppleがAmazon、Google、Zigbee Allianceと、スマートホームデバイスに関するワーキンググループを結成したとのビッグニュースが発表されましたね！
https://www.apple.com/jp/newsroom/2019/12/amazon-apple-google-and-the-zigbee-alliance-to-develop-connectivity-standard/
これに伴い、HomeKitに対応したアクセサリを開発するためのHomeKit ADKがオープンソース化されました。
https://github.com/apple/HomeKitADK
HomeKit対応アクセサリ作ってみよう！？ ちなみにHomeKitの世界ではHomeKitに対応した機器のことをアクセサリと呼びます。
ということで早速HomeKit対応アクセサリを作ってみましょう！ といってもハードウェアを作るわけではなく、手元のMac上で動き、HomeアプリからOnするとSlackになにか投稿するというアクセサリを作る実験をしてみようと思います。
と考えたわけですが、12/23現在ですとまだドキュメント等も優しくはないので、リポジトリを覗いてもなにがなんやらの状態です。
ひとまず、READMEに書かれているとおりに、必要なものをbrew installして、make allすれば、なにやらビルドは成功します。そして、ビルドされた
Output/Darwin-x86_64-apple-darwin19.0.0/Debug/IP/Applications/Lightbulb.OpenSSL  を実行したらなにやら動きます1。
こちらですが、
 まず、HomeKit対応したアクセサリはHomeKit Accessory Protocol（HAP）により操作される HomeKit対応するアクセサリではHAP Accessory Serverが動いている必要があり、これによりHomeアプリへの追加だったり、「ライトを点灯して」といった命令を受け入れる 上で動かしているLightbulb.OpenSSLは、ライト用のHAP Accessoryのサンプル  という理解で良さそうです。
LightbulbのサンプルをiPhoneのHomeアプリに追加してみよう 上のLightbulb.OpenSSLを動かしている状態で、iPhoneのHomeアプリを起動し、以下のようにすると、このサンプルのアクセサリを実際に追加できます。
 アクセサリの追加から「コードがないか、スキャンできません」を選ぶ 近くのアクセサリに「Acme Light Bulb」というのが表示されるので追加する 設定コードの入力を求められるので11122333を入力する  なお、設定コードは https://github.com/tokorom/HomeKitADK/blob/lightbulb_slack/PAL/Mock/HAPPlatformAccessorySetup.c#L12 に書かれていたものを使ってみました。将来、このサンプル用の設定コードは変わるかもしれません。
これでサンプルのLightbulbがHomeアプリに追加されましたので、Homeアプリ上でこのサンプルのライトを点灯/消灯することができるようになりました。
といっても実際に電球があるわけではないので、点灯したよ、消灯したよ、というのはログ上で確認できるのみです。ライトの点灯/消灯を切り替えると、
Info HandleLightBulbOnWrite: true Info HandleLightBulbOnWrite: false  といったログが確認できるかと思います。
サンプルを改造してSlackにメッセージを送信させよう HomeKit対応したライトを作る場合は、上のHandleLightBulbOnWriteのところで実際にライトを点灯させるコードを書くことになりそうです（Raspberry Piなどでそれをやってみるのも簡単と思います）。
今回はSlackにメッセージを送信するアクセサリを作るというのが目的なので、
https://github.com/tokorom/HomeKitADK/blob/lightbulb_slack/Applications/Lightbulb/App.c#L165-L184
このあたりに、SlackにメッセージをPOSTする機能を追加しましょう。
ただ、今回は実験なので（正直、C言語で書いてビルドし直して&amp;hellip;というのが面倒なので）、
#include &amp;lt;stdlib.h&amp;gt;  して、
if (value) { system(&amp;quot;./handleLightBulbOn&amp;quot;); }  ライトがOnになったら外部のShellスクリプトを叩くという実装だけして、あとはShellスクリプトで書く&amp;hellip;という形に逃げちゃいます。。。
      </description>
      
      <coverImage>https://raw.githubusercontent.com/tokorom/tokorom.github.com/images/images/homekitadk/homekit_logo.png</coverImage>
      
    </item>
    
    <item>
      <title>NFCタグ で鍵を開けよう（6） iOS13時代の最終形</title>
      <link>https://www.tokoro.me/posts/nfc-iphone-6/</link>
      <pubDate>Wed, 30 Oct 2019 13:57:46 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/nfc-iphone-6/</guid>
      <description>
        この記事は「NFCタグ で鍵を開けよう」シリーズの第6弾です。 これで最後の予定です。
 NFCタグにURIを書き込む iPhoneを鍵とし、ドアにNFCタグを設置するパターン iOSアプリを経由してセキュリティレベルをあげる NFCタグを鍵とし、ドアにNFCリーダーを設置するパターン（まだ書いてないけど気が向いたら書くかも） より実用的にしていくために iOS13時代の最終形（この記事）  3〜5についてはiOS13の機能を使った最終形で、もうこれでいいじゃん！となったのでスキップします。（NFCタグを鍵にするパターンはまだ必要なケースあるかも）
なにができる？ iOS 13でNFCタグをトリガーとしてアプリを叩けるようになった iOS 13（正確にはiOS 13.1）で、純正アプリの ショートカット にオートメーションという機能が追加されました。 このオートメーションのトリガーの１つに、なんと NFCタグ があるのです。
そして、それをトリガーとしてサードパーティ製アプリの Siri Shortcut を呼び出せます。 つまり、アプリがSiri Shortcutに対応していれば、そのアプリをNFCタグタッチだけで動作させられるようになったということです。 そして、我らがSesameもこれに対応しています。
１行でまとめると、
iOS 13なら何も開発しないで、NFCタグタッチでSesameの解錠ができる  ということです。
対応デバイス 正確には、iOS 13であっても Background Tag Reading に対応したiPhoneでないとこの機能は使えません。2019年10月時点での対応機種は、
 iPhone XR iPhone XS iPhone XS Max iPhone 11 iPhone 11 Pro iPhone 11 Pro Max  の６機種です。
実際にやってみよう NFCタグの準備 NFCタグには何も情報を書き込む必要はありません。
 など適当なNFCタグを買ってきたままそのまま使えます。
オートメーションの作成 次に、ショートカットアプリでオートメーションを設定します。
解錠をマイショートカットとして追加 Sesameを普段から使っていれば、ギャラリータブの中に 「xxx」を解錠 というSesame用のショートカットが含まれているはずです。それに適当な音声コマンドをあてて Siriに追加 をしておきます。Siriに追加されたショートカットをオートメーションのアクションとして指定できるようになります。
      </description>
      
      <coverImage>https://raw.githubusercontent.com/tokorom/tokorom.github.com/images/images/sesame.png</coverImage>
      
    </item>
    
    <item>
      <title>iOSDC Japan 2019 に「Advanced Segue」というセッションで登壇します</title>
      <link>https://www.tokoro.me/posts/iosdc_2019_pre/</link>
      <pubDate>Wed, 04 Sep 2019 18:09:20 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/iosdc_2019_pre/</guid>
      <description>
        明日、2019年9月5日（木）から開催される iOSDC Japan 2019 に「Advanced Segue」というセッションで登壇予定です。
スケジュール  2019/09/05（木） 18:40〜  Track B レギュラートーク（30分） Proposal    概要 Proposalからの抜粋です。
 Segueでできること、できないこと、とにかくSegue（UIStoryboardSegue）について凝縮して紹介します。 通常の使い方からUnwindSegueを使うメリット、Xcode 11から利用できるようになったIBSegueActionまで。 Segueを愛して7年の私が、これまでSegueを避けてきた皆さんにもSegueの魅力を知っていただけるようなトークができればと考えています。
 見ていただきたいかた  同じくSegueを愛する同士 Segueを使ってはいるがもう少しどうにかならないかと思っているかた 敢えてSegueを使っていないかた  Segueを愛するかたはもちろんですが、敢えてSegueを使っていないかたにこそ価値のあるセッションになるかもしれません。 なお、このセッションを聞いて絶対Segueを使ってくれ！とは考えていないです。 普段Segueを使っていないかたにとっては、３０分でSegueについてキャッチアップしていただき「SegueのProsはもちろん知ってるけど、やはり敢えて使ってないんだよ」と自信を持って言える状態になっていただければ幸いです。
具体的な内容  Basic Segue iOS 13 New Features! Advanced Tips  というAgendaの予定です。
Basic Segue  SegueはViewControllerを開くためだけにあるのではないですよ Segueには大きく４種がありますよ  という基本部分と、
 Segueを使うPros Segueを使うCons  について簡単に復習をさせていただきます。
 prepareForSegue  についてもここに含みます。
iOS 13 New Features!  Segue ActionによりSegueのConsの解決  を中心にお話します。
      </description>
      
      <coverImage>https://raw.githubusercontent.com/tokorom/tokorom.github.com/images/images/iosdc_2019.png</coverImage>
      
    </item>
    
    <item>
      <title>NFCタグ で鍵を開けよう（2） iPhoneを鍵とし、ドアにNFCタグを設置するパターン</title>
      <link>https://www.tokoro.me/posts/nfc-iphone-2/</link>
      <pubDate>Mon, 01 Apr 2019 15:11:25 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/nfc-iphone-2/</guid>
      <description>
        この記事は「NFCタグ で鍵を開けよう」シリーズの第2弾です。 このシリーズは以下５つの記事に分けられて投稿予定です。
 NFCタグにURIを書き込む iPhoneを鍵とし、ドアにNFCタグを設置するパターン（この記事） iOSアプリを経由してセキュリティレベルをあげる NFCタグを鍵とし、ドアにNFCリーダーを設置するパターン（まだ書いてないけど気が向いたら書くかも） より実用的にしていくために iOS13時代の最終形  この記事でやること 前回は、NFCタグにhttps://tag.exsample.com/lockというURIを書き込むことに成功し、それをiPhone XR/XSで読み込めることを確認しました。
今回は、このURIで動作するAPIをAWS Lambda1などで作成し、そこからSesame APIを叩いて鍵のアンロックを実現します。
それさえできれば、NFCタグを自宅のドアなどに貼っておけば、iPhoneをそのNFCタグにタッチして鍵をロック/アンロックできるようになるはずです。
 この記事は実験レベルでセキュリティを考慮していません。例えばこの記事で作ったURLを誰かに知られてしまうと、誰でも鍵を開けることができてしまうため、絶対にこのまま実用しないでください！  Sesame APIの利用 APIキーの取得 Sesame APIを叩くうえで必要なAPIキーやSesame ID（device_id）の取得方法についてはCANDY HOUSEのオフィシャルブログ
https://ameblo.jp/candyhouse-inc/entry-12416936959.html
をご参照ください。
API仕様 Sesame APIの仕様については https://docs.candyhouse.co/ にきちんとしたドキュメントがあります。
curlで叩いてみる curl -H &amp;quot;Authorization: YOUR_AUTH_TOKEN&amp;quot; \ https://api.candyhouse.co/public/sesames  で、管理しているデバイスのリストが取得できます。 YOUR_AUTH_TOKENはAPIキーに置き換えてください。
 レスポンス例  [{&amp;quot;device_id&amp;quot;: &amp;quot;aaaaaaaa-aaaa-aaaa-1111-111111111111&amp;quot;, &amp;quot;serial&amp;quot;: &amp;quot;ABCDEFG&amp;quot;, &amp;quot;nickname&amp;quot;: &amp;quot;\u30c9\u30a2&amp;quot;}]  鍵をロック 上で取得したdevice_idを利用し、
curl -H &amp;quot;Authorization: YOUR_AUTH_TOKEN&amp;quot; \ -H &amp;quot;Content-Type: application/json&amp;quot; \ -X POST -d &#39;{&amp;quot;command&amp;quot;:&amp;quot;lock&amp;quot;}&#39; \ https://api.
      </description>
      
      <coverImage>https://raw.githubusercontent.com/tokorom/tokorom.github.com/images/images/sesame.png</coverImage>
      
    </item>
    
    <item>
      <title>NFCタグ で鍵を開けよう（1） NFCタグにURIを書き込む</title>
      <link>https://www.tokoro.me/posts/nfc-iphone-1/</link>
      <pubDate>Mon, 01 Apr 2019 12:43:04 +0900</pubDate>
      
      <guid>https://www.tokoro.me/posts/nfc-iphone-1/</guid>
      <description>
        この記事は「NFCタグ で鍵を開けよう」シリーズの第1弾です。 以下、5つの記事に分けて投稿していく予定です。
 NFCタグにURIを書き込む（この記事） iPhoneを鍵とし、ドアにNFCタグを設置するパターン iOSアプリを経由してセキュリティレベルをあげる NFCタグを鍵とし、ドアにNFCリーダーを設置するパターン（まだ書いてないけど気が向いたら書くかも） より実用的にしていくために iOS13時代の最終形  導入 我が家にスマートロックのSesameを採用しました。
私一人ならSesameだけでものすごく便利になったわけですが、我が家には小さい子供が３人います。子供たちにスマホを持たせるにはまだ早く、このままではスマートロックの恩恵を十分に受けることができません。
なお、Sesameは個人が触れる便利なAPIを公開してくれています。NFC＋Sesame APIでこの状況を改善できるものではないか、と思い立ったのがこの記事を書くきっかけです。まだ現在進行形で実験中ですが、実験した結果を随時記事にしていければと考えています。
この記事でやること 私がNFCタグを取り扱ったことがないところからスタートしましたので、まずこの記事では「NFCタグに情報を書き込む」ところまでだけが範囲になります。
実際にSesameをアンロックするところなどは次の記事で書かせていただきます。
準備した機器 スマートロック 導入に書いたとおりですが、Sesameを購入しました。
 APIでのロックやアンロックが可能で自由度が高そうだったのがSesameを選んだ理由です。
利用するNFCタグ サンワサプライ NFCタグ(10枚入り)をAmazonで購入しました。
 NFCリーダー/ライター NFCリーダー/ライターとしてはPaSoRiを購入しました。
 これも使えればどれでも良いと思いますが、ネット上で利用実績が多く安全そうなものを選んだだけです。
nfcpyでNFCタグの情報を扱う まずはMacにNFCリーダーを接続してNFCタグから情報を読み取るところからはじめます。
調べたところnfcpyというツールがよく使われているようです。 実際に使ってみたところ確かに簡単に利用でき、読み取りから書き込みまでこれで全て完結できそうです。
このツールのexamplesフォルダにそのまま使える便利なサンプルがたくさん入っていました。
情報の読み取り NFCタグに書き込まれた情報を読み取るにはexsamplesの中のtagtool.pyを使って
python tagtool.py show  とするだけです。
フォーマット NFCタグをフォーマットしたいときもtagtool.pyを使って
python tagtool.py format  とするだけです。
URI書き込み NFCタグにURIを書き込みたい場合のみ少し工夫が必要でした。 とはいえ、exsamplesの中にあるものだけで改造なしで可能です。
例えばhttps://tag.exsample.com/lockというURIを書き込むこととします。
まず、うまくいくパターンからですが、
echo -n \\0x04tag.exsample.com/lock | python ndeftool.py pack -t urn:nfc:wkt:U - | python tagtool.py load -  でURIを書き込み可能です。 まず、NFCタグに書き込む情報はNDEF（NFC Data Exchange Format）でないといけないようです。NDEFではText、URI、SmartPosterなどのRecord Typeを扱えます。
      </description>
      
      <coverImage>https://raw.githubusercontent.com/tokorom/tokorom.github.com/images/images/sesame.png</coverImage>
      
    </item>
    
  </channel>
</rss>
